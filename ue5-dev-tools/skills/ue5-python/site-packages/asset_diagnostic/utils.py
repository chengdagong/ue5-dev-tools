# asset_diagnostic/utils.py
# Common utility functions for UE5 asset diagnostics

import unreal
import math


# Cache for default pawn size to avoid repeated lookups
_default_pawn_size_cache = None


def get_default_pawn_size():
    """
    Get the size of the default player pawn class.

    This function attempts to find the default pawn in the following order:
    1. GameMode configured in WorldSettings
    2. Global default GameMode from project settings
    3. BP_RobotBase as fallback (project-specific default)

    Returns:
        tuple: (x_extent, y_extent, z_extent) or None if not found
    """
    global _default_pawn_size_cache

    # Return cached value if available
    if _default_pawn_size_cache is not None:
        return _default_pawn_size_cache

    try:
        # Try to get from WorldSettings
        editor_subsystem = unreal.get_editor_subsystem(unreal.UnrealEditorSubsystem)
        world = editor_subsystem.get_editor_world()

        if world:
            world_settings = world.get_world_settings()
            if world_settings:
                game_mode = world_settings.get_editor_property("default_game_mode")

                if game_mode and isinstance(game_mode, unreal.Class):
                    cdo = unreal.get_default_object(game_mode)
                    default_pawn_class = cdo.get_editor_property("default_pawn_class")

                    if default_pawn_class:
                        size = _get_pawn_size_from_class(default_pawn_class)
                        if size:
                            _default_pawn_size_cache = size
                            return size

        # Fallback: Try to load BP_RobotBase directly (project-specific)
        try:
            bp_class = unreal.EditorAssetLibrary.load_blueprint_class(
                "/Game/Blueprints/Robot/BP_RobotBase"
            )
            if bp_class:
                size = _get_pawn_size_from_class(bp_class)
                if size:
                    _default_pawn_size_cache = size
                    return size
        except:
            pass

    except Exception:
        pass

    return None


def _get_pawn_size_from_class(pawn_class):
    """
    Helper function to get size from a pawn class.

    Args:
        pawn_class: The pawn class to get size from

    Returns:
        tuple: (x_extent, y_extent, z_extent) or None
    """
    try:
        cdo = unreal.get_default_object(pawn_class)

        if isinstance(cdo, unreal.Character):
            components = cdo.get_components_by_class(unreal.CapsuleComponent)
            if components and len(components) > 0:
                capsule = components[0]
                radius = capsule.get_editor_property("capsule_radius")
                half_height = capsule.get_editor_property("capsule_half_height")
                return (radius * 2, radius * 2, half_height * 2)
    except:
        pass

    return None


def get_actor_size(actor):
    """
    Get the bounding box size of an actor along each world axis.

    For Character subclasses, only considers the Capsule Component (CollisionCylinder) size.
    For PlayerStart actors, returns default pawn size.

    Returns:
        tuple: (x_extent, y_extent, z_extent) in unreal units, or None if no bounds

        UE5 World Coordinate System:
        - X-axis: Forward/Back direction
        - Y-axis: Left/Right direction
        - Z-axis: Up/Down direction
    """
    try:
        # Special handling for PlayerStart - use default pawn size
        if isinstance(actor, unreal.PlayerStart):
            # Try to get default pawn size from game mode
            default_size = get_default_pawn_size()
            if default_size:
                return default_size

            # Fallback to standard human-sized capsule (typical character dimensions)
            # Radius: 42 units (84 diameter), Height: 192 units (96 half-height * 2)
            return (84.0, 84.0, 192.0)

        # Special handling for Character subclasses - use Capsule Component only
        if isinstance(actor, unreal.Character):
            # Try to get the Capsule Component
            capsule = actor.get_component_by_class(unreal.CapsuleComponent)
            if capsule:
                # Get capsule dimensions
                radius = capsule.get_scaled_capsule_radius()
                half_height = capsule.get_scaled_capsule_half_height()

                # Capsule dimensions: radius defines X/Y, half_height defines Z
                # Full dimensions (diameter and full height)
                x_extent = radius * 2  # Diameter in X direction
                y_extent = radius * 2  # Diameter in Y direction
                z_extent = half_height * 2  # Full height in Z direction

                return (x_extent, y_extent, z_extent)

        # For all other actors, use standard bounds (only colliding components for accuracy)
        origin, box_extent = actor.get_actor_bounds(only_colliding_components=True)

        if box_extent and (box_extent.x > 0 or box_extent.y > 0 or box_extent.z > 0):
            # box_extent is half-size, multiply by 2 to get full dimensions
            x_extent = box_extent.x * 2  # Size along X-axis (Forward/Back)
            y_extent = box_extent.y * 2  # Size along Y-axis (Left/Right)
            z_extent = box_extent.z * 2  # Size along Z-axis (Up/Down)
            return (x_extent, y_extent, z_extent)
    except Exception:
        pass

    return None


def yaw_to_direction(yaw):
    """
    Convert yaw angle to cardinal direction string.

    Args:
        yaw: Yaw angle in degrees

    Returns:
        str: Direction string like "North", "North-East", etc.

    UE5 Coordinate System:
        - Yaw = 0:    +X direction (North)
        - Yaw = 90:   +Y direction (East)
        - Yaw = 180:  -X direction (South)
        - Yaw = -90:  -Y direction (West)
    """
    # Normalize yaw to [0, 360)
    yaw = yaw % 360

    # Define direction ranges (8 cardinal directions)
    # Each direction covers 45 degrees (22.5 degrees on each side)
    directions = [
        (337.5, 22.5, "North"),  # 0 +/- 22.5
        (22.5, 67.5, "North-East"),  # 45 +/- 22.5
        (67.5, 112.5, "East"),  # 90 +/- 22.5
        (112.5, 157.5, "South-East"),  # 135 +/- 22.5
        (157.5, 202.5, "South"),  # 180 +/- 22.5
        (202.5, 247.5, "South-West"),  # 225 +/- 22.5
        (247.5, 292.5, "West"),  # 270 +/- 22.5
        (292.5, 337.5, "North-West"),  # 315 +/- 22.5
    ]

    # Special case for North (wraps around 0)
    if yaw >= 337.5 or yaw < 22.5:
        return "North"

    for min_angle, max_angle, direction in directions:
        if min_angle <= yaw < max_angle:
            return direction

    return "North"  # Fallback


def get_actor_facing_direction(actor):
    """
    Get the facing direction of an actor.

    Args:
        actor: UE5 Actor object

    Returns:
        tuple: (yaw, pitch, roll, direction_string, forward_vector) or None if unable to get rotation

    Note:
        Direction is determined by the forward vector:
        - Vertical (|Z| > 0.7): "Up" or "Down"
        - Tilted (0.3 < |Z| < 0.7): "North tilted 30 deg up"
        - Horizontal (|Z| < 0.3): "North", "South-East", etc.
    """
    try:
        rotation = actor.get_actor_rotation()
        yaw = rotation.yaw
        pitch = rotation.pitch
        roll = rotation.roll

        # Get forward vector to determine actual facing direction
        forward = rotation.get_forward_vector()

        # 1. Check for vertical orientation (|Z| > 0.7)
        if forward.z > 0.7:
            # Pointing upward
            direction = "Up"
        elif forward.z < -0.7:
            # Pointing downward
            direction = "Down"

        # 2. Check for tilted orientation (0.3 < |Z| < 0.7)
        elif abs(forward.z) > 0.3:
            # Calculate horizontal direction component
            horizontal_yaw = math.atan2(forward.y, forward.x) * (180.0 / math.pi)
            base_direction = yaw_to_direction(horizontal_yaw)

            # Calculate tilt angle
            tilt_angle = math.asin(forward.z) * (180.0 / math.pi)
            tilt_dir = "up" if tilt_angle > 0 else "down"

            direction = f"{base_direction} tilted {abs(tilt_angle):.0f} deg {tilt_dir}"

        # 3. Horizontal orientation (|Z| < 0.3)
        else:
            # Use horizontal component (X, Y) to determine facing direction
            horizontal_yaw = math.atan2(forward.y, forward.x) * (180.0 / math.pi)
            direction = yaw_to_direction(horizontal_yaw)

        return (yaw, pitch, roll, direction, forward)
    except Exception:
        return None


def calculate_distance(a1, a2):
    """Calculate 3D distance between two actors (dict with x, y, z keys)."""
    dx = a1["x"] - a2["x"]
    dy = a1["y"] - a2["y"]
    dz = a1["z"] - a2["z"]
    return math.sqrt(dx * dx + dy * dy + dz * dz)


def calculate_distance_2d(a1, a2):
    """Calculate 2D distance (X-Y plane) between two actors."""
    dx = a1["x"] - a2["x"]
    dy = a1["y"] - a2["y"]
    return math.sqrt(dx * dx + dy * dy)


def get_direction(from_actor, to_actor):
    """
    Get cardinal direction from one actor to another.
    Returns direction string like "north", "southeast", etc.
    UE5: +X = Forward (North), +Y = Right (East), +Z = Up
    """
    dx = to_actor["x"] - from_actor["x"]
    dy = to_actor["y"] - from_actor["y"]

    # Determine primary and secondary directions
    ns = ""
    ew = ""

    if abs(dx) > 50:  # Threshold for "significant" difference
        ns = "north" if dx > 0 else "south"
    if abs(dy) > 50:
        ew = "east" if dy > 0 else "west"

    if ns and ew:
        return f"{ns}-{ew}"
    elif ns:
        return ns
    elif ew:
        return ew
    else:
        return "vertically-aligned"


def get_vertical_relation(from_actor, to_actor):
    """Get vertical relationship between actors."""
    dz = to_actor["z"] - from_actor["z"]
    if dz > 50:
        return f"{dz:.0f} units above"
    elif dz < -50:
        return f"{abs(dz):.0f} units below"
    else:
        return "same-level"


def classify_actor_size(actor):
    """Classify actor by size category."""
    volume = actor["x_extent"] * actor["y_extent"] * actor["z_extent"]
    max_dim = max(actor["x_extent"], actor["y_extent"], actor["z_extent"])

    if volume > 1000000 or max_dim > 500:
        return "LARGE"
    elif volume > 10000 or max_dim > 100:
        return "MEDIUM"
    else:
        return "SMALL"
