# editor_capture/window_capture.py
# Windows window capture and input simulation for UE5
#
# Provides functions to capture UE5 editor windows and simulate keyboard/mouse input.
# Windows-only: Uses Windows API via ctypes.
#
# Usage:
#   from editor_capture import window_capture
#   window_capture.capture_ue5_window("C:/Screenshots/editor.png")
#   window_capture.switch_to_tab(tab_number=1)

import unreal
import time
import os
import ctypes
from ctypes import wintypes


# ============================================
# Windows API Constants
# ============================================

_PW_RENDERFULLCONTENT = 0x00000002
_SRCCOPY = 0x00CC0020
_BI_RGB = 0
_DIB_RGB_COLORS = 0
_INPUT_TYPE_KEYBOARD = 1
_INPUT_TYPE_MOUSE = 0
_KEYEVENTF_KEYUP = 0x0002
_MOUSEEVENTF_LEFTDOWN = 0x0002
_MOUSEEVENTF_LEFTUP = 0x0004

# Virtual key codes
_VK_CONTROL = 0x11
_VK_SHIFT = 0x10
_VK_MENU = 0x12  # Alt key

_VK_NUMBERS = {
    1: 0x31, 2: 0x32, 3: 0x33, 4: 0x34, 5: 0x35,
    6: 0x36, 7: 0x37, 8: 0x38, 9: 0x39,
}

# Windows API handles
_user32 = ctypes.windll.user32
_gdi32 = ctypes.windll.gdi32


# ============================================
# Windows API Structures
# ============================================

class _BITMAPINFOHEADER(ctypes.Structure):
    _fields_ = [
        ('biSize', wintypes.DWORD),
        ('biWidth', wintypes.LONG),
        ('biHeight', wintypes.LONG),
        ('biPlanes', wintypes.WORD),
        ('biBitCount', wintypes.WORD),
        ('biCompression', wintypes.DWORD),
        ('biSizeImage', wintypes.DWORD),
        ('biXPelsPerMeter', wintypes.LONG),
        ('biYPelsPerMeter', wintypes.LONG),
        ('biClrUsed', wintypes.DWORD),
        ('biClrImportant', wintypes.DWORD),
    ]


class _BITMAPINFO(ctypes.Structure):
    _fields_ = [
        ('bmiHeader', _BITMAPINFOHEADER),
        ('bmiColors', wintypes.DWORD * 3),
    ]


class _KEYBDINPUT(ctypes.Structure):
    _fields_ = [
        ('wVk', wintypes.WORD),
        ('wScan', wintypes.WORD),
        ('dwFlags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.POINTER(ctypes.c_ulong)),
    ]


class _MOUSEINPUT(ctypes.Structure):
    _fields_ = [
        ('dx', wintypes.LONG),
        ('dy', wintypes.LONG),
        ('mouseData', wintypes.DWORD),
        ('dwFlags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.POINTER(ctypes.c_ulong)),
    ]


class _INPUT_KEYBOARD(ctypes.Structure):
    _fields_ = [
        ('type', wintypes.DWORD),
        ('ki', _KEYBDINPUT),
        ('padding', ctypes.c_ubyte * 8),
    ]


class _INPUT_MOUSE(ctypes.Structure):
    _fields_ = [
        ('type', wintypes.DWORD),
        ('mi', _MOUSEINPUT),
        ('padding', ctypes.c_ubyte * 8),
    ]


# ============================================
# Internal Helpers
# ============================================

def _ensure_directory(path):
    """Ensure the directory for a file path exists."""
    output_dir = os.path.dirname(path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)


def _get_window_rect(hwnd):
    """Get window rectangle as RECT structure."""
    rect = wintypes.RECT()
    _user32.GetWindowRect(hwnd, ctypes.byref(rect))
    return rect


def _send_key(vk_code, flags=0):
    """Send a single key press using Windows API."""
    inp = _INPUT_KEYBOARD()
    inp.type = _INPUT_TYPE_KEYBOARD
    inp.ki.wVk = vk_code
    inp.ki.wScan = 0
    inp.ki.dwFlags = flags
    inp.ki.time = 0
    inp.ki.dwExtraInfo = None
    _user32.SendInput(1, ctypes.byref(inp), ctypes.sizeof(_INPUT_KEYBOARD))


def _press_key_combo(modifiers, key_vk):
    """Press a key combination (e.g., Shift+F1)."""
    for mod in modifiers:
        _send_key(mod, flags=0)
        time.sleep(0.02)

    _send_key(key_vk, flags=0)
    time.sleep(0.02)
    _send_key(key_vk, flags=_KEYEVENTF_KEYUP)
    time.sleep(0.02)

    for mod in reversed(modifiers):
        _send_key(mod, flags=_KEYEVENTF_KEYUP)
        time.sleep(0.02)


def _click_at(x, y):
    """Simulate a mouse click at the given screen coordinates."""
    _user32.SetCursorPos(x, y)
    time.sleep(0.05)

    inp = _INPUT_MOUSE()
    inp.type = _INPUT_TYPE_MOUSE
    inp.mi.dx = 0
    inp.mi.dy = 0
    inp.mi.mouseData = 0
    inp.mi.time = 0
    inp.mi.dwExtraInfo = None

    inp.mi.dwFlags = _MOUSEEVENTF_LEFTDOWN
    _user32.SendInput(1, ctypes.byref(inp), ctypes.sizeof(_INPUT_MOUSE))
    time.sleep(0.05)

    inp.mi.dwFlags = _MOUSEEVENTF_LEFTUP
    _user32.SendInput(1, ctypes.byref(inp), ctypes.sizeof(_INPUT_MOUSE))
    time.sleep(0.05)


# ============================================
# Window Management Functions
# ============================================

def find_ue5_window():
    """
    Find the UE5 Editor window by current process ID.

    Returns:
        int: Window handle (hwnd) if found, None otherwise
    """
    pid = os.getpid()
    found_hwnd = []

    WNDENUMPROC = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_void_p, ctypes.c_void_p)

    def enum_callback(hwnd, lparam):
        if not _user32.IsWindowVisible(hwnd):
            return True

        window_pid = ctypes.c_ulong()
        _user32.GetWindowThreadProcessId(hwnd, ctypes.byref(window_pid))

        if window_pid.value == pid:
            length = _user32.GetWindowTextLengthW(hwnd)
            if length > 0:
                buff = ctypes.create_unicode_buffer(length + 1)
                _user32.GetWindowTextW(hwnd, buff, length + 1)
                found_hwnd.append((hwnd, buff.value))
                return False
        return True

    _user32.EnumWindows(WNDENUMPROC(enum_callback), 0)

    if found_hwnd:
        hwnd, title = found_hwnd[0]
        unreal.log(f"[INFO] Found UE5 window (PID={pid}): {title}")
        return hwnd
    return None


def set_foreground_window(hwnd):
    """
    Set a window to foreground.

    Args:
        hwnd: Window handle

    Returns:
        bool: True if successful
    """
    return bool(_user32.SetForegroundWindow(hwnd))


def get_foreground_window():
    """
    Get the current foreground window handle.

    Returns:
        int: Window handle
    """
    return _user32.GetForegroundWindow()


# ============================================
# Input Simulation Functions
# ============================================

def switch_to_tab(tab_number=1, hwnd=None):
    """
    Switch to a specific tab in Blueprint Editor using keyboard shortcut.
    Clicks window center to ensure focus, then sends Ctrl+Shift+Alt+<number>.

    Args:
        tab_number: Tab number to switch to (1-9, default: 1 for Viewport)
        hwnd: Window handle (optional, will find UE5 window if not provided)

    Returns:
        bool: True if key combo was sent, False otherwise
    """
    if tab_number not in _VK_NUMBERS:
        unreal.log_error(f"[ERROR] Invalid tab number: {tab_number} (must be 1-9)")
        return False

    if hwnd is None:
        hwnd = find_ue5_window()

    if not hwnd:
        unreal.log_error("[ERROR] Cannot switch tab: UE5 window not found")
        return False

    _user32.SetForegroundWindow(hwnd)
    time.sleep(0.2)

    window_rect = _get_window_rect(hwnd)
    center_x = (window_rect.left + window_rect.right) // 2
    center_y = (window_rect.top + window_rect.bottom) // 2

    unreal.log(f"[INFO] Clicking window center at ({center_x}, {center_y}) to ensure focus...")
    _click_at(center_x, center_y)
    time.sleep(0.3)

    unreal.log(f"[INFO] Sending Ctrl+Shift+Alt+{tab_number} to switch to tab {tab_number}...")
    _press_key_combo([_VK_CONTROL, _VK_SHIFT, _VK_MENU], _VK_NUMBERS[tab_number])
    time.sleep(0.5)
    return True


def switch_to_viewport_tab(hwnd=None):
    """Switch to viewport tab (tab 1). Convenience wrapper for switch_to_tab."""
    return switch_to_tab(tab_number=1, hwnd=hwnd)


def click_window_center(hwnd=None):
    """
    Click the center of a window.

    Args:
        hwnd: Window handle (optional, will find UE5 window if not provided)

    Returns:
        bool: True if successful
    """
    if hwnd is None:
        hwnd = find_ue5_window()

    if not hwnd:
        unreal.log_error("[ERROR] Window not found")
        return False

    window_rect = _get_window_rect(hwnd)
    center_x = (window_rect.left + window_rect.right) // 2
    center_y = (window_rect.top + window_rect.bottom) // 2

    _click_at(center_x, center_y)
    return True


# ============================================
# Screenshot Functions
# ============================================

def capture_window(hwnd, crop_titlebar=True):
    """
    Capture window using PrintWindow API (works for background/hidden windows).

    Args:
        hwnd: Window handle
        crop_titlebar: If True, crop titlebar and keep only client area

    Returns:
        PIL Image object, None if failed
    """
    try:
        from PIL import Image
    except ImportError:
        unreal.log_error("[ERROR] PIL/Pillow not installed. Run: pip install Pillow")
        return None

    try:
        ctypes.windll.shcore.SetProcessDpiAwareness(2)
    except Exception:
        pass

    window_rect = _get_window_rect(hwnd)
    client_rect = wintypes.RECT()
    _user32.GetClientRect(hwnd, ctypes.byref(client_rect))

    point = wintypes.POINT(0, 0)
    _user32.ClientToScreen(hwnd, ctypes.byref(point))
    titlebar_height = point.y - window_rect.top
    border_left = point.x - window_rect.left

    width = window_rect.right - window_rect.left
    height = window_rect.bottom - window_rect.top
    unreal.log(f"[DEBUG] Capture window rect: ({window_rect.left}, {window_rect.top}) size: {width}x{height}")

    if width <= 0 or height <= 0:
        unreal.log_error(f"[ERROR] Invalid window size ({width}x{height})")
        return None

    hwnd_dc = _user32.GetWindowDC(hwnd)
    mfc_dc = _gdi32.CreateCompatibleDC(hwnd_dc)
    bitmap = _gdi32.CreateCompatibleBitmap(hwnd_dc, width, height)
    old_bitmap = _gdi32.SelectObject(mfc_dc, bitmap)

    result = _user32.PrintWindow(hwnd, mfc_dc, _PW_RENDERFULLCONTENT)
    if not result:
        unreal.log_warning("[WARNING] PrintWindow failed, trying BitBlt...")
        _gdi32.BitBlt(mfc_dc, 0, 0, width, height, hwnd_dc, 0, 0, _SRCCOPY)

    bmi = _BITMAPINFO()
    bmi.bmiHeader.biSize = ctypes.sizeof(_BITMAPINFOHEADER)
    bmi.bmiHeader.biWidth = width
    bmi.bmiHeader.biHeight = -height
    bmi.bmiHeader.biPlanes = 1
    bmi.bmiHeader.biBitCount = 32
    bmi.bmiHeader.biCompression = _BI_RGB

    buffer = ctypes.create_string_buffer(width * height * 4)
    _gdi32.GetDIBits(mfc_dc, bitmap, 0, height, buffer, ctypes.byref(bmi), _DIB_RGB_COLORS)

    _gdi32.SelectObject(mfc_dc, old_bitmap)
    _gdi32.DeleteObject(bitmap)
    _gdi32.DeleteDC(mfc_dc)
    _user32.ReleaseDC(hwnd, hwnd_dc)

    img = Image.frombuffer('RGBA', (width, height), buffer, 'raw', 'BGRA', 0, 1)

    if crop_titlebar and (titlebar_height > 0 or border_left > 0):
        client_width = client_rect.right - client_rect.left
        client_height = client_rect.bottom - client_rect.top
        img = img.crop((border_left, titlebar_height, border_left + client_width, titlebar_height + client_height))

    return img


def capture_ue5_window(output_path, crop_titlebar=True):
    """
    Capture the UE5 Editor window using PrintWindow API.

    Args:
        output_path: Path to save the screenshot
        crop_titlebar: If True, crop titlebar and keep only client area

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        _ensure_directory(output_path)

        hwnd = find_ue5_window()
        if not hwnd:
            unreal.log_error("[ERROR] Could not find UE5 Editor window")
            return False

        img = capture_window(hwnd, crop_titlebar)
        if img is None:
            unreal.log_error("[ERROR] Failed to capture window")
            return False

        img.save(output_path)
        unreal.log(f"[OK] UE5 window screenshot saved to: {output_path} ({img.width}x{img.height})")
        return True

    except Exception as e:
        unreal.log_error(f"[ERROR] Failed to capture UE5 window: {e}")
        return False


# ============================================
# Combined Functions
# ============================================

def open_asset_and_screenshot(asset_path, output_path, delay=3.0, tab_number=None, crop_titlebar=True):
    """
    Open an asset editor and take a screenshot after a delay.

    Args:
        asset_path: The asset path to open
        output_path: Path to save the screenshot
        delay: Seconds to wait before taking screenshot (default: 3.0)
        tab_number: Tab number to switch to (1-9, None to skip switching)
        crop_titlebar: If True, crop titlebar from screenshot

    Returns:
        dict: {"opened": bool, "screenshot": bool, "screenshot_path": str}
    """
    from . import asset_editor

    result = {"opened": False, "screenshot": False, "screenshot_path": None}

    prev_active_hwnd = get_foreground_window()
    unreal.log(f"[INFO] Recorded original active window: {prev_active_hwnd}")

    hwnd = find_ue5_window()
    if not hwnd:
        unreal.log_error("[ERROR] Could not find UE5 Editor window")
        return result

    try:
        if not asset_editor.open_asset_editor(asset_path):
            return result
        result["opened"] = True

        unreal.log(f"[INFO] Waiting {delay}s for editor to render...")
        time.sleep(delay)

        if tab_number is not None:
            switch_to_tab(tab_number, hwnd)
            time.sleep(0.5)

        _ensure_directory(output_path)
        img = capture_window(hwnd, crop_titlebar)
        if img:
            img.save(output_path)
            unreal.log(f"[OK] UE5 window screenshot saved to: {output_path} ({img.width}x{img.height})")
            result["screenshot"] = True
            result["screenshot_path"] = output_path
        else:
            unreal.log_error("[ERROR] Failed to capture window")

    finally:
        if prev_active_hwnd:
            _user32.SetForegroundWindow(prev_active_hwnd)
            unreal.log(f"[INFO] Restored original active window: {prev_active_hwnd}")
            time.sleep(0.1)

    return result


def batch_asset_screenshots(asset_paths, output_dir, delay=3.0, tab_number=None, close_after=True):
    """
    Open multiple asset editors one by one and take screenshots of each.

    Args:
        asset_paths: List of asset paths to open
        output_dir: Directory to save screenshots
        delay: Seconds to wait before each screenshot (default: 3.0)
        tab_number: Tab number to switch to (1-9, None to skip switching)
        close_after: Close each asset editor after screenshot (default: True)

    Returns:
        dict: {"success": [(path, screenshot_path)], "failed": [path]}
    """
    from . import asset_editor

    results = {"success": [], "failed": []}

    if not asset_paths:
        unreal.log_warning("[WARNING] No asset paths provided")
        return results

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for asset_path in asset_paths:
        asset_name = asset_path.split("/")[-1]
        screenshot_path = os.path.join(output_dir, f"{asset_name}.png")

        result = open_asset_and_screenshot(
            asset_path, screenshot_path, delay, tab_number
        )

        if result["opened"] and result["screenshot"]:
            results["success"].append((asset_path, result["screenshot_path"]))
            unreal.log(f"[OK] {asset_path} -> {result['screenshot_path']}")
        else:
            results["failed"].append(asset_path)
            unreal.log_error(f"[ERROR] Failed: {asset_path}")

        if close_after:
            asset_editor.close_asset_editor(asset_path)
        time.sleep(0.5)

    unreal.log("=" * 50)
    unreal.log(f"[SUMMARY] Success: {len(results['success'])}, Failed: {len(results['failed'])}")
    return results
