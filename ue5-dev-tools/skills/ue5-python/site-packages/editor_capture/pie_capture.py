# editor_capture/pie_capture.py
# PIE (Play In Editor) screenshot capture for UE5
#
# Auto-captures screenshots during PIE runtime using tick callbacks,
# with multi-angle support for capturing the player character from
# multiple viewpoints.
#
# Usage:
#   from editor_capture import pie_capture
#
#   # Start capturer and auto-start PIE (default: screenshot every 1 second, multi-angle mode)
#   capturer = pie_capture.start_pie_capture(auto_start_pie=True)
#
#   # Single angle mode
#   capturer = pie_capture.start_pie_capture(auto_start_pie=True, multi_angle=False)
#
#   # Custom multi-angle parameters
#   capturer = pie_capture.start_pie_capture(
#       output_dir="C:/Screenshots",
#       interval_seconds=2.0,
#       resolution=(1920, 1080),
#       auto_start_pie=True,
#       multi_angle=True,
#       camera_distance=400,
#       target_height=90
#   )
#
#   # Stop capturer
#   pie_capture.stop_pie_capture()
#
#   # PIE session controls
#   pie_capture.start_pie_session()
#   pie_capture.stop_pie_session()
#   pie_capture.is_pie_running()

import unreal
import os
import math
from datetime import datetime


# ============================================
# VIEW CONFIGURATIONS
# ============================================

PIE_CAPTURE_VIEWS = [
    {"name": "front", "display_name": "Front View", "yaw": 180, "pitch": 0, "use_height_offset": True},
    {"name": "side", "display_name": "Side View", "yaw": 180, "pitch": 0, "use_height_offset": True},
    {"name": "top", "display_name": "Top View", "yaw": 0, "pitch": -90, "use_height_offset": False},
    {"name": "perspective", "display_name": "45-Degree Perspective", "yaw": -135, "pitch": -35, "distance_multiplier": 0.707},
]


# ============================================
# INTERNAL HELPERS
# ============================================

def _get_level_editor_subsystem():
    """
    Get the LevelEditorSubsystem.

    Returns:
        tuple: (subsystem, error_message) - subsystem is None if failed
    """
    subsystem = unreal.get_editor_subsystem(unreal.LevelEditorSubsystem)
    if not subsystem:
        return None, "Failed to get LevelEditorSubsystem"
    return subsystem, None


def _get_actor_subsystem():
    """
    Get the EditorActorSubsystem.

    Returns:
        tuple: (subsystem, error_message) - subsystem is None if failed
    """
    subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
    if not subsystem:
        return None, "Failed to get EditorActorSubsystem"
    return subsystem, None


def _ensure_output_directory(path):
    """
    Ensure output directory exists, creating it if necessary.

    Args:
        path: Directory path to ensure exists
    """
    if not os.path.exists(path):
        os.makedirs(path)
        unreal.log(f"[INFO] Created output directory: {path}")


def _calculate_pie_camera_transform(target, view_config, camera_distance, target_height):
    """
    Calculate camera position and rotation for PIE capture based on view configuration.

    Uses direct offset calculations matching the original implementation.

    Args:
        target: Target location (unreal.Vector) - already includes target_height offset
        view_config: View configuration dict from PIE_CAPTURE_VIEWS
        camera_distance: Base distance from target
        target_height: Height offset for target

    Returns:
        tuple: (camera_location, camera_rotation)
    """
    name = view_config["name"]
    yaw = view_config["yaw"]
    pitch = view_config["pitch"]
    distance_multiplier = view_config.get("distance_multiplier", 1.0)

    d = camera_distance * distance_multiplier
    h = target_height

    # Calculate offset based on view name (matching original offset_func lambdas)
    if name == "front":
        # lambda d, h: (0, d, h) - camera behind target in Y+ direction
        offset = (0, d, h)
    elif name == "side":
        # lambda d, h: (d, 0, h) - camera to the side in X+ direction
        offset = (d, 0, h)
    elif name == "top":
        # lambda d, _h: (0, 0, d) - camera directly above
        offset = (0, 0, d)
    elif name == "perspective":
        # lambda d, _h: (d * 0.707, d * 0.707, d * 0.707) - 45-degree diagonal
        offset = (d * 0.707, d * 0.707, d * 0.707)
    else:
        # Fallback for custom views - use simple offset based on distance
        offset = (0, d, h)

    # Calculate camera position
    # Subtract target_height from Z since it's already added to target
    cam_x = target.x + offset[0]
    cam_y = target.y + offset[1]
    cam_z = target.z + offset[2] - target_height

    camera_location = unreal.Vector(cam_x, cam_y, cam_z)
    camera_rotation = unreal.Rotator(roll=0, pitch=pitch, yaw=yaw)

    return camera_location, camera_rotation


# ============================================
# PIE CAPTURER CLASS
# ============================================

class PIECapturer:
    """PIE screenshot capturer using tick callbacks, with multi-angle support."""

    def __init__(
        self,
        output_dir=None,
        interval_seconds=1.0,
        resolution=(1920, 1080),
        multi_angle=True,
        camera_distance=300,
        target_height=90,
        views=None
    ):
        """
        Initialize the PIE capturer.

        Args:
            output_dir: Screenshot output directory, defaults to project Screenshots/PIE_Captures
            interval_seconds: Screenshot interval in seconds
            resolution: Screenshot resolution (width, height)
            multi_angle: Enable multi-angle capture (4 angles)
            camera_distance: Camera distance from target
            target_height: Target height offset (from ground)
            views: Custom view configurations (defaults to PIE_CAPTURE_VIEWS)
        """
        # Set output directory
        if output_dir is None:
            project_dir = unreal.Paths.project_dir()
            output_dir = os.path.join(project_dir, "Screenshots", "PIE_Captures")

        self.output_dir = output_dir
        self.interval_seconds = interval_seconds
        self.resolution = resolution
        self.multi_angle = multi_angle
        self.camera_distance = camera_distance
        self.target_height = target_height
        self.views = views if views is not None else PIE_CAPTURE_VIEWS

        # State variables
        self._tick_handle = None
        self._accumulated_time = 0.0
        self._screenshot_count = 0
        self._is_running = False
        self._pending_task = None
        self._was_in_pie = False
        self._camera_actor = None

        # Multi-angle state machine
        self._current_angle_index = 0
        self._capture_in_progress = False
        self._capture_timestamp = ""
        self._capture_base_count = 0
        self._capture_target = None

        # Ensure output directory exists
        _ensure_output_directory(self.output_dir)

    def start(self):
        """Start the capturer."""
        if self._is_running:
            unreal.log_warning("[WARNING] PIE capturer already running")
            return

        self._is_running = True
        self._accumulated_time = 0.0
        self._screenshot_count = 0
        self._was_in_pie = False
        self._pending_task = None
        self._current_angle_index = 0
        self._capture_in_progress = False

        # Create camera for multi-angle capture
        if self.multi_angle:
            self._create_camera()

        # Register tick callback
        self._tick_handle = unreal.register_slate_post_tick_callback(self._on_tick)

        mode_str = f"Multi-angle ({len(self.views)} views)" if self.multi_angle else "Single view"
        unreal.log(f"[OK] PIE capturer started - Mode: {mode_str}")
        unreal.log(f"[INFO] Interval: {self.interval_seconds}s, Resolution: {self.resolution}")
        if self.multi_angle:
            unreal.log(f"[INFO] Camera distance: {self.camera_distance}, Target height: {self.target_height}")
        unreal.log(f"[INFO] Output: {self.output_dir}")

    def stop(self):
        """Stop the capturer."""
        if not self._is_running:
            unreal.log_warning("[WARNING] PIE capturer not running")
            return

        self._is_running = False

        # Unregister tick callback
        if self._tick_handle is not None:
            unreal.unregister_slate_post_tick_callback(self._tick_handle)
            self._tick_handle = None

        # Destroy camera (check if still valid)
        if self._camera_actor is not None:
            try:
                if self._camera_actor.is_valid():
                    self._camera_actor.destroy_actor()
            except Exception:
                pass  # Camera already destroyed (e.g., when PIE ended)
            self._camera_actor = None

        unreal.log(f"[OK] PIE capturer stopped - Total screenshots: {self._screenshot_count}")

    def _create_camera(self):
        """Create camera actor for multi-angle capture."""
        actor_subsystem, error = _get_actor_subsystem()
        if error:
            unreal.log_error(f"[ERROR] {error}")
            return

        self._camera_actor = actor_subsystem.spawn_actor_from_class(
            unreal.CameraActor,
            unreal.Vector(0, 0, 0),
            transient=True
        )
        if self._camera_actor:
            self._camera_actor.set_actor_label("PIE_Screenshot_Camera")
            unreal.log("[OK] Created screenshot camera")
        else:
            unreal.log_error("[ERROR] Failed to create camera actor")

    def _get_target_location(self, pie_world):
        """Get target location for capture (player character position)."""
        # Try to get player character
        player_char = unreal.GameplayStatics.get_player_character(pie_world, 0)
        if player_char:
            loc = player_char.get_actor_location()
            return unreal.Vector(loc.x, loc.y, loc.z + self.target_height)

        # If no player character, try to get player pawn
        player_pawn = unreal.GameplayStatics.get_player_pawn(pie_world, 0)
        if player_pawn:
            loc = player_pawn.get_actor_location()
            return unreal.Vector(loc.x, loc.y, loc.z + self.target_height)

        # Default position
        return unreal.Vector(0, 0, self.target_height)

    def _on_tick(self, delta_time):
        """Tick callback function."""
        if not self._is_running:
            return

        # Check for pending screenshot task
        if self._pending_task is not None:
            if self._pending_task.is_task_done():
                self._pending_task = None
                # If multi-angle capture in progress, continue to next angle
                if self._capture_in_progress:
                    self._take_next_angle()
                    return
            else:
                # Task not complete, skip this tick
                return

        # Check PIE state
        pie_worlds = unreal.EditorLevelLibrary.get_pie_worlds(False)
        is_in_pie = len(pie_worlds) > 0

        # Detect PIE state changes
        if is_in_pie and not self._was_in_pie:
            unreal.log("[INFO] PIE started - beginning capture")
            self._accumulated_time = 0.0
            self._capture_in_progress = False
        elif not is_in_pie and self._was_in_pie:
            unreal.log("[INFO] PIE ended - pausing capture")
            self._capture_in_progress = False

        self._was_in_pie = is_in_pie

        # If not in PIE, don't capture
        if not is_in_pie:
            return

        # If multi-angle capture in progress, don't accumulate time
        if self._capture_in_progress:
            return

        # Accumulate time
        self._accumulated_time += delta_time

        # Check if screenshot interval reached
        if self._accumulated_time >= self.interval_seconds:
            self._accumulated_time = 0.0
            pie_world = pie_worlds[0]

            if self.multi_angle:
                self._start_multi_angle_capture(pie_world)
            else:
                self._take_single_screenshot()

    def _take_single_screenshot(self):
        """Take single-angle screenshot."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = os.path.join(
            self.output_dir,
            f"PIE_Screenshot_{timestamp}_{self._screenshot_count:04d}.png"
        )

        unreal.AutomationLibrary.finish_loading_before_screenshot()

        self._pending_task = unreal.AutomationLibrary.take_high_res_screenshot(
            res_x=self.resolution[0],
            res_y=self.resolution[1],
            filename=filename,
            camera=None,
            mask_enabled=False,
            capture_hdr=False,
            comparison_tolerance=unreal.ComparisonTolerance.LOW,
            comparison_notes="",
            delay=0.0,
            force_game_view=True
        )

        self._screenshot_count += 1
        unreal.log(f"[OK] Screenshot #{self._screenshot_count}: {os.path.basename(filename)}")

    def _start_multi_angle_capture(self, pie_world):
        """Start multi-angle capture sequence."""
        if self._camera_actor is None:
            unreal.log_error("[ERROR] Camera not available for multi-angle capture")
            self._take_single_screenshot()
            return

        # Initialize multi-angle capture state
        self._capture_in_progress = True
        self._current_angle_index = 0
        self._capture_timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._capture_base_count = self._screenshot_count
        self._capture_target = self._get_target_location(pie_world)

        unreal.log(f"[INFO] Starting multi-angle capture at target: ({self._capture_target.x:.0f}, {self._capture_target.y:.0f}, {self._capture_target.z:.0f})")

        # Capture first angle
        self._take_current_angle()

    def _take_current_angle(self):
        """Capture current angle."""
        if self._current_angle_index >= len(self.views):
            # All angles captured
            self._capture_in_progress = False
            self._screenshot_count += 1
            unreal.log(f"[OK] Completed set #{self._screenshot_count} ({len(self.views)} angles)")
            return

        view_config = self.views[self._current_angle_index]

        # Calculate camera position and rotation
        cam_pos, cam_rot = _calculate_pie_camera_transform(
            self._capture_target,
            view_config,
            self.camera_distance,
            self.target_height
        )

        # Move camera
        self._camera_actor.set_actor_location_and_rotation(
            cam_pos, cam_rot, sweep=False, teleport=True
        )

        # Generate filename
        filename = os.path.join(
            self.output_dir,
            f"PIE_Screenshot_{self._capture_timestamp}_{self._capture_base_count:04d}_{view_config['name']}.png"
        )

        unreal.AutomationLibrary.finish_loading_before_screenshot()

        # Take screenshot
        self._pending_task = unreal.AutomationLibrary.take_high_res_screenshot(
            res_x=self.resolution[0],
            res_y=self.resolution[1],
            filename=filename,
            camera=self._camera_actor,
            mask_enabled=False,
            capture_hdr=False,
            comparison_tolerance=unreal.ComparisonTolerance.LOW,
            comparison_notes="",
            delay=0.0,
            force_game_view=True
        )

        unreal.log(f"[OK] Screenshot {view_config['name']}: {os.path.basename(filename)}")

    def _take_next_angle(self):
        """Capture next angle."""
        self._current_angle_index += 1
        self._take_current_angle()


# ============================================
# MODULE-LEVEL FUNCTIONS
# ============================================

# Global instance
_capturer_instance = None


def start_pie_capture(
    output_dir=None,
    interval_seconds=1.0,
    resolution=(1920, 1080),
    auto_start_pie=False,
    multi_angle=True,
    camera_distance=300,
    target_height=90,
    views=None
):
    """
    Start PIE screenshot capturer.

    Args:
        output_dir: Screenshot output directory
        interval_seconds: Screenshot interval in seconds
        resolution: Screenshot resolution (width, height)
        auto_start_pie: Whether to auto-start PIE
        multi_angle: Enable multi-angle capture (4 angles: front, side, top, 45-degree perspective)
        camera_distance: Camera distance from target
        target_height: Target height offset
        views: Custom view configurations (defaults to PIE_CAPTURE_VIEWS)

    Returns:
        PIECapturer instance
    """
    global _capturer_instance

    if _capturer_instance is not None:
        _capturer_instance.stop()

    _capturer_instance = PIECapturer(
        output_dir=output_dir,
        interval_seconds=interval_seconds,
        resolution=resolution,
        multi_angle=multi_angle,
        camera_distance=camera_distance,
        target_height=target_height,
        views=views
    )
    _capturer_instance.start()

    # Auto-start PIE if requested
    if auto_start_pie:
        start_pie_session()

    return _capturer_instance


def stop_pie_capture():
    """Stop PIE screenshot capturer."""
    global _capturer_instance

    if _capturer_instance is not None:
        _capturer_instance.stop()
        _capturer_instance = None


def get_pie_capturer():
    """Get current capturer instance."""
    return _capturer_instance


def start_pie_session():
    """Start PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is already running")
        return False

    subsystem.editor_request_begin_play()
    unreal.log("[OK] PIE start requested")
    return True


def stop_pie_session():
    """Stop PIE (Play In Editor) session."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        unreal.log_error(f"[ERROR] {error}")
        return False

    if not subsystem.is_in_play_in_editor():
        unreal.log_warning("[WARNING] PIE is not running")
        return False

    subsystem.editor_request_end_play()
    unreal.log("[OK] PIE stop requested")
    return True


def is_pie_running():
    """Check if PIE is currently running."""
    subsystem, error = _get_level_editor_subsystem()
    if error:
        return False
    return subsystem.is_in_play_in_editor()


# If running this script directly, start capturer and auto-start PIE (multi-angle mode)
if __name__ == "__main__":
    start_pie_capture(auto_start_pie=True, multi_angle=True)
