# asset_diagnostic/diagnostics/level.py
# Level/Map asset diagnostic

import unreal
import math
from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass

from .base import BaseDiagnostic
from ..core import AssetType, DiagnosticResult, IssueSeverity
from ..utils import (
    get_actor_size,
    get_actor_facing_direction,
    calculate_distance,
    calculate_distance_2d,
    get_direction,
    get_vertical_relation,
    classify_actor_size,
    aabb_intersects,
    is_horizontal_orientation,
    get_actor_bounds,
)


# Actor classes that are considered "tangible" (have physical presence)
TANGIBLE_CLASSES = [
    "StaticMeshActor",
    "SkeletalMeshActor",
    "Character",
    "Pawn",
    "PlayerStart",
]

# Non-physical actor classes to skip
NON_PHYSICAL_CLASSES = [
    "DirectionalLight",
    "PointLight",
    "SpotLight",
    "RectLight",
    "SkyLight",
    "SkyAtmosphere",
    "VolumetricCloud",
    "ExponentialHeightFog",
    "AtmosphericFog",
    "Fog",
    "PostProcessVolume",
    "LightmassImportanceVolume",
    "NavMeshBoundsVolume",
    "BlockingVolume",
    "CameraActor",
    "LevelSequenceActor",
    "Note",
    "WorldSettings",
]

# Ground detection constants
GROUND_CLASSES = ["Landscape", "LandscapeProxy", "LandscapeStreamingProxy"]
GROUND_AREA_THRESHOLD = 100000  # 1000x100 units minimum area for flat surface detection
GROUND_FLATNESS_RATIO = 5  # XY extent must be 5x greater than Z extent
GROUND_TAGS = ["Ground", "Floor"]  # Tags that identify ground actors

# Orientation tolerance for character checks
HORIZONTAL_TOLERANCE_DEGREES = 5.0


@dataclass
class ActorSupportInfo:
    """Information about an actor for support chain analysis."""

    actor: unreal.Actor
    origin: unreal.Vector
    box_extent: unreal.Vector
    is_supported: bool = False
    support_depth: int = -1  # -1=unsupported, 0=ground, 1+=chain depth


class LevelDiagnostic(BaseDiagnostic):
    """
    Diagnostic for UE5 Level/Map assets.

    Checks for:
    - Missing PlayerStart
    - Actor positioning issues
    - Spatial layout analysis
    - Potential collision issues (with attach relationship exclusion)
    - Floating objects (support chain propagation)
    - Character orientation (pitch/roll within ±5°)
    """

    @property
    def supported_types(self) -> List[AssetType]:
        return [AssetType.LEVEL]

    def diagnose(self, asset_path: str = None, verbose: bool = False) -> DiagnosticResult:
        """
        Perform level diagnostics.

        Args:
            asset_path: Optional level path. If None, uses current open level.
            verbose: If True, print comprehensive level analysis in addition to issues.

        Returns:
            DiagnosticResult with issues found
        """
        # Get current level if path not specified
        if asset_path is None:
            asset_path = self._get_current_level_path() or "CurrentLevel"

        result = self._create_result(asset_path, AssetType.LEVEL)

        # Get all actors
        actors = self._get_all_actors()
        if not actors:
            result.add_issue(
                IssueSeverity.WARNING,
                "Level",
                "No actors found in the current level",
            )
            return result

        result.metadata["total_actors"] = len(actors)

        # Get tangible actors for spatial analysis
        tangible_actors = self._get_tangible_actors(actors)
        result.metadata["tangible_actors"] = len(tangible_actors)

        # Run diagnostic checks
        self._check_player_start(actors, result)
        self._check_actor_positions(tangible_actors, result)
        self._check_overlapping_actors(tangible_actors, result)
        self._check_floating_actors(actors, result)
        self._check_character_orientation(actors, result)

        # Generate spatial analysis
        spatial_info = self._generate_spatial_analysis(tangible_actors)
        result.metadata.update(spatial_info)

        # Print detailed level info only in verbose mode
        if verbose:
            self._print_level_analysis(actors, tangible_actors, result)

        return result

    def _get_current_level_path(self) -> Optional[str]:
        """Get the path of the currently open level."""
        try:
            editor_subsystem = unreal.get_editor_subsystem(unreal.UnrealEditorSubsystem)
            world = editor_subsystem.get_editor_world()
            if world:
                level = world.get_outer()
                if level:
                    return level.get_path_name()
        except Exception:
            pass
        return None

    def _get_all_actors(self) -> List[unreal.Actor]:
        """Get all actors in the current level."""
        try:
            actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
            return list(actor_subsystem.get_all_level_actors())
        except Exception:
            return []

    def _is_tangible_actor(self, actor) -> bool:
        """Check if an actor has physical presence."""
        class_name = actor.get_class().get_name()

        for skip in NON_PHYSICAL_CLASSES:
            if skip.lower() in class_name.lower():
                return False

        for tangible in TANGIBLE_CLASSES:
            if tangible.lower() in class_name.lower():
                return True

        # Blueprint classes end with _C
        if class_name.endswith("_C"):
            return True

        return False

    def _get_tangible_actors(self, actors: List[unreal.Actor]) -> List[Dict[str, Any]]:
        """Get tangible actors with their position/size data."""
        tangible = []
        for actor in actors:
            if not self._is_tangible_actor(actor):
                continue

            size = get_actor_size(actor)
            if not size:
                continue

            location = actor.get_actor_location()
            tangible.append(
                {
                    "name": actor.get_actor_label(),
                    "class": actor.get_class().get_name(),
                    "x": location.x,
                    "y": location.y,
                    "z": location.z,
                    "x_extent": size[0],
                    "y_extent": size[1],
                    "z_extent": size[2],
                    "actor": actor,
                }
            )
        return tangible

    def _check_player_start(
        self, actors: List[unreal.Actor], result: DiagnosticResult
    ):
        """Check for PlayerStart presence and configuration."""
        player_starts = [a for a in actors if isinstance(a, unreal.PlayerStart)]

        if not player_starts:
            result.add_issue(
                IssueSeverity.WARNING,
                "Gameplay",
                "No PlayerStart found in the level",
                evidence=["Players will not have a spawn location"],
                suggestion="Add a PlayerStart actor for player spawn location",
            )
        elif len(player_starts) > 1:
            ps_names = [ps.get_actor_label() for ps in player_starts]
            result.add_issue(
                IssueSeverity.INFO,
                "Gameplay",
                f"Multiple PlayerStart actors found ({len(player_starts)})",
                evidence=[f"PlayerStarts: {', '.join(ps_names)}"],
            )
        # Check each PlayerStart for position and orientation issues
        for ps in player_starts:
            location = ps.get_actor_location()
            ps_name = ps.get_actor_label()

            # Check for very low Z position
            if location.z < -1000:
                result.add_issue(
                    IssueSeverity.WARNING,
                    "Gameplay",
                    "PlayerStart is at very low Z position",
                    actor=ps_name,
                    evidence=[
                        f"Position: ({location.x:.0f}, {location.y:.0f}, {location.z:.0f})",
                        f"Z position {location.z:.0f} is below -1000",
                    ],
                    suggestion="Ensure PlayerStart is at a valid spawn height",
                )

            # Check for non-horizontal facing direction
            is_horizontal, pitch, roll = is_horizontal_orientation(
                ps, HORIZONTAL_TOLERANCE_DEGREES
            )
            if not is_horizontal:
                rotation = ps.get_actor_rotation()
                evidence = [
                    f"Position: ({location.x:.0f}, {location.y:.0f}, {location.z:.0f})",
                    f"Rotation: Pitch={pitch:.1f}, Roll={roll:.1f}, Yaw={rotation.yaw:.1f}",
                    f"Tolerance: +/-{HORIZONTAL_TOLERANCE_DEGREES} degrees",
                ]
                if abs(pitch) > HORIZONTAL_TOLERANCE_DEGREES:
                    evidence.append(
                        f"Pitch exceeds tolerance by {abs(pitch) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees"
                    )
                if abs(roll) > HORIZONTAL_TOLERANCE_DEGREES:
                    evidence.append(
                        f"Roll exceeds tolerance by {abs(roll) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees"
                    )
                result.add_issue(
                    IssueSeverity.WARNING,
                    "Orientation",
                    "PlayerStart facing direction is not horizontal",
                    actor=ps_name,
                    evidence=evidence,
                    suggestion="Adjust PlayerStart rotation so pitch and roll are within tolerance",
                )

        result.metadata["player_start_count"] = len(player_starts)

    def _check_actor_positions(
        self, actors: List[Dict[str, Any]], result: DiagnosticResult
    ):
        """Check for suspicious actor positions."""
        for actor in actors:
            # Check for actors at world origin (might be unintentional)
            if abs(actor["x"]) < 1 and abs(actor["y"]) < 1 and abs(actor["z"]) < 1:
                result.add_issue(
                    IssueSeverity.INFO,
                    "Position",
                    "Actor at world origin (0, 0, 0)",
                    actor=actor["name"],
                    evidence=[
                        f"Position: ({actor['x']:.1f}, {actor['y']:.1f}, {actor['z']:.1f})",
                        f"Class: {actor['class']}",
                        "This might be intentional or might indicate unplaced actor",
                    ],
                )

            # Check for actors at extreme positions
            if (
                abs(actor["x"]) > 1000000
                or abs(actor["y"]) > 1000000
                or abs(actor["z"]) > 1000000
            ):
                result.add_issue(
                    IssueSeverity.WARNING,
                    "Position",
                    "Actor at extreme position (possible placement error)",
                    actor=actor["name"],
                    evidence=[
                        f"Position: ({actor['x']:.0f}, {actor['y']:.0f}, {actor['z']:.0f})",
                        f"Class: {actor['class']}",
                        "Position exceeds 1,000,000 units on at least one axis",
                    ],
                    suggestion="Verify actor placement - may be outside playable area",
                )

    def _check_overlapping_actors(
        self, actors: List[Dict[str, Any]], result: DiagnosticResult
    ):
        """
        Check for potentially overlapping actors.

        Excludes actors with parent-child attachment relationships from
        being flagged as overlapping.
        """
        overlap_threshold = 10  # units

        for i, a1 in enumerate(actors):
            a1_actor = a1["actor"]
            a1_exclude = self._build_attach_exclude_set(a1_actor)

            for a2 in actors[i + 1 :]:
                a2_actor = a2["actor"]

                # Skip if actors have attachment relationship
                if a2_actor in a1_exclude:
                    continue

                dist = calculate_distance(a1, a2)
                min_separation = (
                    max(a1["x_extent"], a1["y_extent"])
                    + max(a2["x_extent"], a2["y_extent"])
                ) / 2

                if dist < overlap_threshold and a1["class"] == a2["class"]:
                    result.add_issue(
                        IssueSeverity.INFO,
                        "Collision",
                        "Two actors of same class potentially overlapping",
                        evidence=[
                            f"Actor 1: {a1['name']} at ({a1['x']:.0f}, {a1['y']:.0f}, {a1['z']:.0f})",
                            f"Actor 2: {a2['name']} at ({a2['x']:.0f}, {a2['y']:.0f}, {a2['z']:.0f})",
                            f"Class: {a1['class']}",
                            f"Distance between centers: {dist:.1f} units",
                            f"Overlap threshold: {overlap_threshold} units",
                        ],
                    )

    def _generate_spatial_analysis(
        self, actors: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Generate spatial analysis metadata."""
        if not actors:
            return {}

        min_x = min(a["x"] for a in actors)
        max_x = max(a["x"] for a in actors)
        min_y = min(a["y"] for a in actors)
        max_y = max(a["y"] for a in actors)
        min_z = min(a["z"] for a in actors)
        max_z = max(a["z"] for a in actors)

        return {
            "level_bounds": {
                "min": (min_x, min_y, min_z),
                "max": (max_x, max_y, max_z),
            },
            "level_dimensions": {
                "width": max_x - min_x,
                "length": max_y - min_y,
                "height": max_z - min_z,
            },
            "level_center": (
                (min_x + max_x) / 2,
                (min_y + max_y) / 2,
                (min_z + max_z) / 2,
            ),
        }

    # =========================================================================
    # Ground and Floating Object Detection
    # =========================================================================

    def _is_ground_actor(self, actor: unreal.Actor) -> bool:
        """
        Check if an actor qualifies as a ground surface.

        Criteria:
        1. Landscape class actors
        2. Large flat StaticMesh surfaces
        3. Actors with "Ground" or "Floor" tags
        """
        class_name = actor.get_class().get_name()

        # Check if it's a Landscape class
        for ground_class in GROUND_CLASSES:
            if ground_class.lower() in class_name.lower():
                return True

        # Check for Ground/Floor tags
        try:
            tags = actor.tags
            if tags:
                for tag in tags:
                    tag_str = str(tag)
                    for ground_tag in GROUND_TAGS:
                        if ground_tag.lower() in tag_str.lower():
                            return True
        except Exception:
            pass

        # Check for large flat surfaces (StaticMeshActor)
        if "staticmesh" in class_name.lower():
            origin, extent = get_actor_bounds(actor)
            if origin and extent:
                xy_area = extent.x * extent.y * 4  # Full area (extent is half-size)
                avg_xy = (extent.x + extent.y) / 2
                z_extent = extent.z

                # Must be large enough and flat
                if (
                    xy_area > GROUND_AREA_THRESHOLD
                    and z_extent > 0
                    and avg_xy > z_extent * GROUND_FLATNESS_RATIO
                ):
                    return True

        return False

    def _identify_ground_actors(
        self, actors: List[unreal.Actor]
    ) -> List[unreal.Actor]:
        """
        Identify all actors that serve as ground/floor surfaces.

        Args:
            actors: List of all actors in the level

        Returns:
            List of actors classified as ground
        """
        ground_actors = []
        for actor in actors:
            if self._is_ground_actor(actor):
                ground_actors.append(actor)
        return ground_actors

    def _build_attach_exclude_set(self, actor: unreal.Actor) -> Set[unreal.Actor]:
        """
        Build a set of actors to exclude from overlap detection due to
        parent-child attachment relationships.

        Args:
            actor: The actor to build exclusion set for

        Returns:
            Set of actors to exclude (includes self, parent, and children)
        """
        exclude = {actor}
        try:
            parent = actor.get_attach_parent_actor()
            if parent:
                exclude.add(parent)

            attached = actor.get_attached_actors()
            if attached:
                exclude.update(attached)
        except Exception:
            pass
        return exclude

    def _get_overlapping_actors_for_support(
        self,
        actor_info: ActorSupportInfo,
        all_actor_info: Dict[unreal.Actor, ActorSupportInfo],
    ) -> List[unreal.Actor]:
        """
        Find actors that overlap with the given actor (for support chain detection).
        Excludes actors with attachment relationships.

        Args:
            actor_info: The actor's support info
            all_actor_info: Dict mapping actors to their support info

        Returns:
            List of overlapping actors
        """
        overlapping = []
        exclude_set = self._build_attach_exclude_set(actor_info.actor)

        for other_actor, other_info in all_actor_info.items():
            if other_actor in exclude_set:
                continue

            # Use AABB intersection test
            if aabb_intersects(
                actor_info.origin,
                actor_info.box_extent,
                other_info.origin,
                other_info.box_extent,
            ):
                overlapping.append(other_actor)

        return overlapping

    def _detect_floating_objects(
        self, actors: List[unreal.Actor], ground_actors: List[unreal.Actor]
    ) -> tuple[List[unreal.Actor], int, Dict[unreal.Actor, ActorSupportInfo]]:
        """
        Detect floating objects using support chain propagation.

        Algorithm:
        1. Mark ground actors as supported (depth=0)
        2. Find actors overlapping ground → mark as supported (depth=1)
        3. Iteratively propagate until no new actors get support status
        4. Return unsupported actors as floating

        Args:
            actors: All tangible actors to check
            ground_actors: Actors identified as ground surfaces

        Returns:
            tuple: (list of floating actors, max support depth, actor_info_map)
        """
        # Build actor info map (cache bounds)
        actor_info_map: Dict[unreal.Actor, ActorSupportInfo] = {}

        for actor in actors:
            origin, extent = get_actor_bounds(actor)
            if origin and extent:
                actor_info_map[actor] = ActorSupportInfo(
                    actor=actor,
                    origin=origin,
                    box_extent=extent,
                )

        # Initialize ground actors as supported (depth=0)
        ground_set = set(ground_actors)
        for actor in ground_actors:
            if actor in actor_info_map:
                actor_info_map[actor].is_supported = True
                actor_info_map[actor].support_depth = 0

        # Propagation loop
        max_depth = 0
        current_depth = 0
        changed = True

        while changed:
            changed = False
            current_depth += 1
            newly_supported = []

            # Find unsupported actors that overlap with supported actors
            for actor, info in actor_info_map.items():
                if info.is_supported:
                    continue

                # Check if this actor overlaps with any supported actor
                overlapping = self._get_overlapping_actors_for_support(
                    info, actor_info_map
                )
                for other in overlapping:
                    other_info = actor_info_map.get(other)
                    if other_info and other_info.is_supported:
                        newly_supported.append((actor, current_depth))
                        break

            # Mark newly supported actors
            for actor, depth in newly_supported:
                actor_info_map[actor].is_supported = True
                actor_info_map[actor].support_depth = depth
                max_depth = max(max_depth, depth)
                changed = True

            # Prevent infinite loops (max depth 100)
            if current_depth > 100:
                break

        # Collect floating (unsupported) actors
        floating = [
            info.actor
            for info in actor_info_map.values()
            if not info.is_supported
        ]

        return floating, max_depth, actor_info_map

    def _check_floating_actors(
        self, actors: List[unreal.Actor], result: DiagnosticResult
    ):
        """
        Check for floating objects in the level.

        Args:
            actors: All actors in the level
            result: DiagnosticResult to add issues to
        """
        # Get tangible actors (raw actor list)
        tangible_actors = [a for a in actors if self._is_tangible_actor(a)]
        if not tangible_actors:
            return

        # Identify ground actors
        ground_actors = self._identify_ground_actors(actors)

        if not ground_actors:
            # No ground detected - can't determine floating status
            result.add_issue(
                IssueSeverity.INFO,
                "Physics",
                "No ground surfaces detected - unable to check for floating objects",
                evidence=[
                    "No Landscape actors found",
                    "No large flat StaticMesh actors found",
                    "No actors with 'Ground' or 'Floor' tags found",
                ],
                suggestion="Add a Landscape, large flat mesh, or tag actors with 'Ground'/'Floor'",
            )
            return

        # Detect floating objects with support info
        floating_actors, max_depth, actor_info_map = self._detect_floating_objects(
            tangible_actors, ground_actors
        )

        # Store metadata
        result.metadata["ground_actors_count"] = len(ground_actors)
        result.metadata["support_chain_max_depth"] = max_depth
        result.metadata["floating_actors_count"] = len(floating_actors)

        # Report floating actors with evidence
        for actor in floating_actors:
            location = actor.get_actor_location()
            actor_name = actor.get_actor_label()

            # Build evidence
            evidence = [
                f"Position: ({location.x:.0f}, {location.y:.0f}, {location.z:.0f})",
                f"Class: {actor.get_class().get_name()}",
            ]

            # Find nearest ground actor
            nearest_ground = None
            nearest_ground_dist = float('inf')
            for g in ground_actors:
                g_loc = g.get_actor_location()
                dist = math.sqrt(
                    (location.x - g_loc.x) ** 2 +
                    (location.y - g_loc.y) ** 2 +
                    (location.z - g_loc.z) ** 2
                )
                if dist < nearest_ground_dist:
                    nearest_ground_dist = dist
                    nearest_ground = g

            if nearest_ground:
                g_loc = nearest_ground.get_actor_location()
                evidence.append(
                    f"Nearest ground: {nearest_ground.get_actor_label()} "
                    f"at ({g_loc.x:.0f}, {g_loc.y:.0f}, {g_loc.z:.0f}), "
                    f"distance: {nearest_ground_dist:.0f} units"
                )

            # Get actor bounds info
            origin, extent = get_actor_bounds(actor)
            if origin and extent:
                bottom_z = origin.z - extent.z
                evidence.append(f"Actor bottom Z: {bottom_z:.0f}")
                if nearest_ground:
                    g_origin, g_extent = get_actor_bounds(nearest_ground)
                    if g_origin and g_extent:
                        ground_top_z = g_origin.z + g_extent.z
                        gap = bottom_z - ground_top_z
                        evidence.append(f"Ground top Z: {ground_top_z:.0f}, Gap: {gap:.0f} units")

            # Check if there are any nearby supported actors
            nearby_supported = []
            if actor in actor_info_map:
                actor_info = actor_info_map[actor]
                for other, other_info in actor_info_map.items():
                    if other == actor or not other_info.is_supported:
                        continue
                    # Calculate distance
                    dist = math.sqrt(
                        (actor_info.origin.x - other_info.origin.x) ** 2 +
                        (actor_info.origin.y - other_info.origin.y) ** 2 +
                        (actor_info.origin.z - other_info.origin.z) ** 2
                    )
                    if dist < 500:  # Within 500 units
                        nearby_supported.append((other.get_actor_label(), dist))

                if nearby_supported:
                    nearby_supported.sort(key=lambda x: x[1])
                    nearest = nearby_supported[0]
                    evidence.append(
                        f"Nearest supported actor: {nearest[0]} ({nearest[1]:.0f} units away)"
                    )
                else:
                    evidence.append("No supported actors within 500 units")

            result.add_issue(
                IssueSeverity.WARNING,
                "Physics",
                "Actor may be floating (no support chain to ground)",
                actor=actor_name,
                evidence=evidence,
                suggestion="Move actor to contact a supported surface, or check collision bounds",
            )

    # =========================================================================
    # Character Orientation Check
    # =========================================================================

    def _is_character_actor(self, actor: unreal.Actor) -> bool:
        """Check if an actor is a Character or Pawn type (including subclasses)."""
        return isinstance(actor, (unreal.Character, unreal.Pawn))

    def _check_character_orientation(
        self, actors: List[unreal.Actor], result: DiagnosticResult
    ):
        """
        Check that all Pawn/Character actors are horizontally oriented.

        Characters should have pitch and roll within ±5° of horizontal.

        Args:
            actors: All actors in the level
            result: DiagnosticResult to add issues to
        """
        character_actors = [a for a in actors if self._is_character_actor(a)]

        for actor in character_actors:
            is_horizontal, pitch, roll = is_horizontal_orientation(
                actor, HORIZONTAL_TOLERANCE_DEGREES
            )

            if not is_horizontal:
                location = actor.get_actor_location()
                rotation = actor.get_actor_rotation()

                evidence = [
                    f"Position: ({location.x:.0f}, {location.y:.0f}, {location.z:.0f})",
                    f"Class: {actor.get_class().get_name()}",
                    f"Rotation: Pitch={pitch:.1f}, Roll={roll:.1f}, Yaw={rotation.yaw:.1f}",
                    f"Tolerance: +/-{HORIZONTAL_TOLERANCE_DEGREES} degrees",
                ]

                if abs(pitch) > HORIZONTAL_TOLERANCE_DEGREES:
                    evidence.append(f"Pitch exceeds tolerance by {abs(pitch) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees")
                if abs(roll) > HORIZONTAL_TOLERANCE_DEGREES:
                    evidence.append(f"Roll exceeds tolerance by {abs(roll) - HORIZONTAL_TOLERANCE_DEGREES:.1f} degrees")

                result.add_issue(
                    IssueSeverity.WARNING,
                    "Orientation",
                    "Character not oriented horizontally",
                    actor=actor.get_actor_label(),
                    evidence=evidence,
                    suggestion="Adjust rotation so pitch and roll are within tolerance",
                )

    def _print_level_analysis(
        self,
        all_actors: List[unreal.Actor],
        tangible_actors: List[Dict[str, Any]],
        result: DiagnosticResult,
    ):
        """Print detailed level analysis."""
        unreal.log("")
        unreal.log("=" * 80)
        unreal.log("LEVEL ANALYSIS")
        unreal.log("=" * 80)

        # Actor summary
        unreal.log(f"\n## ACTOR SUMMARY")
        unreal.log(f"Total actors: {len(all_actors)}")
        unreal.log(f"Tangible actors: {len(tangible_actors)}")

        # Level dimensions
        if "level_dimensions" in result.metadata:
            dims = result.metadata["level_dimensions"]
            unreal.log(f"\n## LEVEL DIMENSIONS")
            unreal.log(
                f"Size: {dims['width']:.0f} x {dims['length']:.0f} x {dims['height']:.0f} units"
            )

        # Actor registry
        if tangible_actors:
            unreal.log(f"\n## ACTOR REGISTRY ({len(tangible_actors)} tangible)")
            unreal.log("-" * 60)

            sorted_actors = sorted(
                tangible_actors,
                key=lambda a: a["x_extent"] * a["y_extent"] * a["z_extent"],
                reverse=True,
            )

            for i, actor in enumerate(sorted_actors[:20], 1):  # Top 20
                size_cat = classify_actor_size(actor)
                unreal.log(f"[{i}] {actor['name']}")
                unreal.log(f"    Type: {actor['class']}")
                unreal.log(
                    f"    Size: {actor['x_extent']:.0f} x {actor['y_extent']:.0f} x {actor['z_extent']:.0f} ({size_cat})"
                )
                unreal.log(
                    f"    Position: ({actor['x']:.0f}, {actor['y']:.0f}, {actor['z']:.0f})"
                )

                facing = get_actor_facing_direction(actor["actor"])
                if facing:
                    yaw, pitch, roll, direction, forward = facing
                    if abs(yaw) > 0.1 or abs(pitch) > 0.1 or abs(roll) > 0.1:
                        unreal.log(f"    Facing: {direction}")

            if len(tangible_actors) > 20:
                unreal.log(f"\n... and {len(tangible_actors) - 20} more actors")

        # Spatial relationships
        if len(tangible_actors) > 1:
            unreal.log(f"\n## SPATIAL RELATIONSHIPS")
            for actor in tangible_actors[:5]:  # Top 5
                relationships = []
                for other in tangible_actors:
                    if other["name"] == actor["name"]:
                        continue
                    dist = calculate_distance_2d(actor, other)
                    direction = get_direction(actor, other)
                    vertical = get_vertical_relation(actor, other)
                    relationships.append(
                        {
                            "target": other["name"],
                            "direction": direction,
                            "vertical": vertical,
                            "dist": dist,
                        }
                    )

                relationships.sort(key=lambda r: r["dist"])

                unreal.log(f"\nFROM: {actor['name']}")
                for rel in relationships[:3]:
                    unreal.log(
                        f"  -> {rel['target']}: {rel['dist']:.0f}u {rel['direction']}, {rel['vertical']}"
                    )

        unreal.log("\n" + "=" * 80)
