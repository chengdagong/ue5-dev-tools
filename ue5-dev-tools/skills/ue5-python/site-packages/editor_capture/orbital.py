# editor_capture/orbital.py
# Multi-angle orbital screenshot capture for UE5
#
# Captures screenshots from multiple angles around a target location
# using SceneCapture2D. Supports perspective, orthographic, and bird's eye views.
#
# Usage:
#   from editor_capture import orbital
#   results = orbital.take_orbital_screenshots(world, target_location=unreal.Vector(0,0,100))

import unreal
import math
import os


# ============================================
# VIEW CONFIGURATIONS
# ============================================

PERSPECTIVE_VIEWS = [
    (270, 0, "front", "Front View"),
    (180, 0, "left", "Left View"),
    (0, 0, "right", "Right View"),
    (90, 0, "back", "Back View"),
]

ORTHOGRAPHIC_VIEWS = [
    (270, 0, "ortho_front", "Ortho Front"),
    (90, 0, "ortho_back", "Ortho Back"),
    (180, 0, "ortho_left", "Ortho Left"),
    (0, 0, "ortho_right", "Ortho Right"),
    (0, -90, "ortho_top", "Ortho Top"),
    (0, 90, "ortho_bottom", "Ortho Bottom"),
]

BIRDSEYE_VIEWS = [
    (270, -45, "birdseye_front", "Bird's Eye Front"),
    (180, -45, "birdseye_left", "Bird's Eye Left"),
    (0, -45, "birdseye_right", "Bird's Eye Right"),
    (90, -45, "birdseye_back", "Bird's Eye Back"),
]

VIEW_PRESETS = {
    "all": {"perspective": True, "orthographic": True, "birdseye": True},
    "perspective": {"perspective": True, "orthographic": False, "birdseye": False},
    "orthographic": {"perspective": False, "orthographic": True, "birdseye": False},
    "birdseye": {"perspective": False, "orthographic": False, "birdseye": True},
    "horizontal": {"perspective": True, "orthographic": False, "birdseye": True},
    "technical": {"perspective": False, "orthographic": True, "birdseye": False},
}


# ============================================
# UTILITY FUNCTIONS
# ============================================

def calculate_camera_transform(target, yaw_deg, pitch_deg, distance):
    """
    Calculate camera position and rotation from orbital parameters.

    Args:
        target: Target location (unreal.Vector)
        yaw_deg: Horizontal angle in degrees (0 = +X direction)
        pitch_deg: Vertical angle in degrees (0 = horizontal, -90 = looking down)
        distance: Distance from target

    Returns:
        tuple: (camera_location, camera_rotation)
    """
    yaw_rad = math.radians(yaw_deg)
    pitch_rad = math.radians(pitch_deg)

    horizontal_distance = distance * math.cos(pitch_rad)
    height_offset = distance * math.sin(-pitch_rad)

    cam_x = target.x + horizontal_distance * math.cos(yaw_rad)
    cam_y = target.y + horizontal_distance * math.sin(yaw_rad)
    cam_z = target.z + height_offset

    camera_location = unreal.Vector(cam_x, cam_y, cam_z)

    dir_x = target.x - cam_x
    dir_y = target.y - cam_y
    dir_z = target.z - cam_z

    calc_yaw = math.degrees(math.atan2(dir_y, dir_x))
    horizontal_dist = math.sqrt(dir_x**2 + dir_y**2)
    calc_pitch = math.degrees(math.atan2(dir_z, horizontal_dist))

    camera_rotation = unreal.Rotator(roll=0, pitch=calc_pitch, yaw=calc_yaw)

    return camera_location, camera_rotation


# ============================================
# HELPER SPAWNING FUNCTIONS
# ============================================

def spawn_reference_grid(actor_subsystem, target_location, grid_size=500.0, divisions=10):
    """
    Spawn a temporary reference grid on the ground plane.

    Args:
        actor_subsystem: EditorActorSubsystem instance
        target_location: Center location for the grid
        grid_size: Total size of the grid
        divisions: Number of grid cells per axis

    Returns:
        list: List of spawned grid actors for cleanup
    """
    grid_actors = []
    cell_size = grid_size / divisions
    half_size = grid_size / 2.0
    grid_z = 0.5
    line_thickness = 2.0

    center_x = target_location.x
    center_y = target_location.y

    # Horizontal lines (along X axis)
    for i in range(divisions + 1):
        y_pos = center_y - half_size + (i * cell_size)
        line_actor = actor_subsystem.spawn_actor_from_class(
            unreal.StaticMeshActor,
            unreal.Vector(center_x, y_pos, grid_z)
        )
        if line_actor:
            line_actor.set_actor_label(f"OrbitalHelper_Grid_H_{i}")
            scale_x = grid_size / 100.0
            scale_y = line_thickness / 100.0
            scale_z = line_thickness / 100.0
            line_actor.set_actor_scale3d(unreal.Vector(scale_x, scale_y, scale_z))
            mesh_comp = line_actor.get_component_by_class(unreal.StaticMeshComponent)
            if mesh_comp:
                cube = unreal.load_asset("/Engine/BasicShapes/Cube")
                if cube:
                    mesh_comp.set_static_mesh(cube)
            grid_actors.append(line_actor)

    # Vertical lines (along Y axis)
    for i in range(divisions + 1):
        x_pos = center_x - half_size + (i * cell_size)
        line_actor = actor_subsystem.spawn_actor_from_class(
            unreal.StaticMeshActor,
            unreal.Vector(x_pos, center_y, grid_z)
        )
        if line_actor:
            line_actor.set_actor_label(f"OrbitalHelper_Grid_V_{i}")
            scale_x = line_thickness / 100.0
            scale_y = grid_size / 100.0
            scale_z = line_thickness / 100.0
            line_actor.set_actor_scale3d(unreal.Vector(scale_x, scale_y, scale_z))
            mesh_comp = line_actor.get_component_by_class(unreal.StaticMeshComponent)
            if mesh_comp:
                cube = unreal.load_asset("/Engine/BasicShapes/Cube")
                if cube:
                    mesh_comp.set_static_mesh(cube)
            grid_actors.append(line_actor)

    unreal.log(f"  [GRID] Spawned {len(grid_actors)} grid lines")
    return grid_actors


def spawn_axis_gizmo(actor_subsystem, target_location, arrow_length=80.0):
    """
    Spawn RGB axis indicator arrows at the target location.

    Args:
        actor_subsystem: EditorActorSubsystem instance
        target_location: Location for the gizmo origin
        arrow_length: Length of each axis arrow

    Returns:
        list: List of spawned gizmo actors for cleanup
    """
    gizmo_actors = []

    shaft_radius = arrow_length * 0.05
    cone_length = arrow_length * 0.2
    cone_radius = arrow_length * 0.1
    shaft_length = arrow_length - cone_length

    base = unreal.Vector(
        target_location.x - arrow_length * 0.5,
        target_location.y - arrow_length * 0.5,
        target_location.z - arrow_length * 0.5
    )

    axes = [
        {"name": "X", "dir": (1, 0, 0), "rotation": unreal.Rotator(roll=0, pitch=0, yaw=90)},
        {"name": "Y", "dir": (0, 1, 0), "rotation": unreal.Rotator(roll=0, pitch=0, yaw=0)},
        {"name": "Z", "dir": (0, 0, 1), "rotation": unreal.Rotator(roll=0, pitch=-90, yaw=0)},
    ]

    for axis in axes:
        dx, dy, dz = axis["dir"]

        # Shaft
        shaft_center = unreal.Vector(
            base.x + dx * (shaft_length / 2),
            base.y + dy * (shaft_length / 2),
            base.z + dz * (shaft_length / 2)
        )
        shaft = actor_subsystem.spawn_actor_from_class(unreal.StaticMeshActor, shaft_center)
        if shaft:
            shaft.set_actor_label(f"OrbitalHelper_Gizmo_{axis['name']}_Shaft")
            shaft.set_actor_rotation(axis["rotation"], False)
            scale_xy = (shaft_radius * 2) / 100.0
            scale_z = shaft_length / 100.0
            shaft.set_actor_scale3d(unreal.Vector(scale_xy, scale_xy, scale_z))
            mesh_comp = shaft.get_component_by_class(unreal.StaticMeshComponent)
            if mesh_comp:
                cylinder = unreal.load_asset("/Engine/BasicShapes/Cylinder")
                if cylinder:
                    mesh_comp.set_static_mesh(cylinder)
            gizmo_actors.append(shaft)

        # Cone (arrowhead)
        cone_center = unreal.Vector(
            base.x + dx * (shaft_length + cone_length / 2),
            base.y + dy * (shaft_length + cone_length / 2),
            base.z + dz * (shaft_length + cone_length / 2)
        )
        cone = actor_subsystem.spawn_actor_from_class(unreal.StaticMeshActor, cone_center)
        if cone:
            cone.set_actor_label(f"OrbitalHelper_Gizmo_{axis['name']}_Cone")
            cone.set_actor_rotation(axis["rotation"], False)
            scale_xy = (cone_radius * 2) / 100.0
            scale_z = cone_length / 100.0
            cone.set_actor_scale3d(unreal.Vector(scale_xy, scale_xy, scale_z))
            mesh_comp = cone.get_component_by_class(unreal.StaticMeshComponent)
            if mesh_comp:
                cone_mesh = unreal.load_asset("/Engine/BasicShapes/Cone")
                if cone_mesh:
                    mesh_comp.set_static_mesh(cone_mesh)
            gizmo_actors.append(cone)

    unreal.log(f"  [GIZMO] Spawned {len(gizmo_actors)} gizmo parts (X/Y/Z axes)")
    return gizmo_actors


# ============================================
# CAPTURE FUNCTIONS
# ============================================

def capture_single_view(
    actor_subsystem,
    loaded_world,
    camera_location,
    camera_rotation,
    view_name,
    display_name,
    output_dir,
    resolution_width,
    resolution_height,
    is_orthographic=False,
    ortho_width=600.0,
    auto_exposure_min=0.3,
    auto_exposure_max=2.0,
    auto_exposure_bias=0.0
):
    """
    Capture a single screenshot from the specified camera position.

    Args:
        auto_exposure_min: Minimum brightness for auto-exposure (default: 0.3)
        auto_exposure_max: Maximum brightness for auto-exposure (default: 2.0)
        auto_exposure_bias: Exposure compensation in EV stops (default: 0.0)

    Returns:
        str or None: Path to saved file, or None if failed
    """
    unreal.log(f"\n[{view_name.upper()}] {display_name} Processing...")

    capture_actor = actor_subsystem.spawn_actor_from_class(
        unreal.SceneCapture2D,
        camera_location
    )

    if not capture_actor:
        unreal.log_warning(f"  [WARNING] Failed to spawn SceneCapture2D")
        return None

    capture_actor.set_actor_rotation(camera_rotation, False)
    capture_actor.set_actor_label(f"OrbitalCapture_{view_name}")

    capture_component = capture_actor.capture_component2d

    if is_orthographic:
        capture_component.set_editor_property("projection_type", unreal.CameraProjectionMode.ORTHOGRAPHIC)
        capture_component.set_editor_property("ortho_width", ortho_width)

    render_target = unreal.RenderingLibrary.create_render_target2d(
        loaded_world,
        resolution_width,
        resolution_height,
        unreal.TextureRenderTargetFormat.RTF_RGBA8
    )

    if not render_target:
        unreal.log_warning(f"  [WARNING] Failed to create render target")
        return None

    capture_component.texture_target = render_target
    capture_component.capture_source = unreal.SceneCaptureSource.SCS_FINAL_COLOR_LDR

    # Enable post-processing to fix dark/high-contrast issues

    # Configure post-process settings for proper exposure and tone mapping
    post_process_settings = unreal.PostProcessSettings()

    # Enable auto-exposure for consistent brightness
    post_process_settings.set_editor_property("auto_exposure_method",
        unreal.AutoExposureMethod.AEM_HISTOGRAM)
    post_process_settings.set_editor_property("auto_exposure_min_brightness", auto_exposure_min)
    post_process_settings.set_editor_property("auto_exposure_max_brightness", auto_exposure_max)
    post_process_settings.set_editor_property("auto_exposure_bias", auto_exposure_bias)

    # Apply post-process settings to the capture component
    capture_component.set_editor_property("post_process_settings", post_process_settings)
    capture_component.set_editor_property("post_process_blend_weight", 1.0)

    capture_component.capture_scene()

    screenshot_filename = view_name
    unreal.RenderingLibrary.export_render_target(
        loaded_world,
        render_target,
        output_dir,
        screenshot_filename
    )

    temp_path = os.path.join(output_dir, screenshot_filename)
    final_path = os.path.join(output_dir, f"{screenshot_filename}.png")

    saved_path = None
    if os.path.exists(temp_path):
        if os.path.exists(final_path):
            os.remove(final_path)
        os.rename(temp_path, final_path)
        saved_path = final_path
        unreal.log(f"  [OK] Saved: {screenshot_filename}.png")
    elif os.path.exists(final_path):
        saved_path = final_path
        unreal.log(f"  [OK] Saved: {screenshot_filename}.png")
    else:
        unreal.log_warning(f"  [WARNING] File not found: {screenshot_filename}")

    return saved_path


def get_next_capture_folder(base_dir, folder_prefix):
    """
    Get the next available capture folder with auto-increment.

    Returns:
        str: Path to the new capture folder
    """
    os.makedirs(base_dir, exist_ok=True)

    existing = []
    if os.path.exists(base_dir):
        for name in os.listdir(base_dir):
            if name.startswith(f"{folder_prefix}_"):
                try:
                    num = int(name[len(folder_prefix) + 1:])
                    existing.append(num)
                except ValueError:
                    pass

    next_num = max(existing, default=0) + 1
    new_folder = os.path.join(base_dir, f"{folder_prefix}_{next_num}")
    os.makedirs(new_folder, exist_ok=True)

    return new_folder


# ============================================
# MAIN CAPTURE FUNCTION
# ============================================

def take_orbital_screenshots(
    loaded_world,
    target_location=None,
    distance=500.0,
    output_dir=None,
    folder_prefix="capture",
    resolution_width=800,
    resolution_height=600,
    enable_perspective_views=True,
    enable_orthographic_views=True,
    enable_birdseye_views=True,
    ortho_width=600.0,
    enable_grid=True,
    grid_size=500.0,
    grid_divisions=10,
    enable_gizmo=True,
    gizmo_size=80.0,
    organize_by_type=True,
    auto_cleanup=True,
    auto_exposure_min=0.3,
    auto_exposure_max=2.0,
    auto_exposure_bias=0.0,
):
    """
    Take multi-angle screenshots around a target location for model validation.

    Supports three view groups:
    - Perspective horizontal views (4 views)
    - Orthographic views (6 views: front, back, left, right, top, bottom)
    - Bird's eye views (4 views at 45-degree elevation)

    Can optionally spawn temporary helpers:
    - Reference grid on ground plane
    - RGB axis indicator (gizmo)

    Args:
        loaded_world: The loaded world/level to capture
        target_location: Center point to orbit around (unreal.Vector, default: origin)
        distance: Distance from target in units (default: 500)
        output_dir: Directory to save screenshots (default: project's Saved/Screenshots/Orbital)
        folder_prefix: Prefix for capture folders (default: "capture")
        resolution_width: Screenshot width (default: 800)
        resolution_height: Screenshot height (default: 600)
        enable_perspective_views: Enable 4 horizontal perspective views (default: True)
        enable_orthographic_views: Enable 6 orthographic views (default: True)
        enable_birdseye_views: Enable 4 bird's eye views (default: True)
        ortho_width: Width of orthographic capture in world units (default: 600)
        enable_grid: Spawn reference grid during capture (default: True)
        grid_size: Size of reference grid in units (default: 500)
        grid_divisions: Number of grid divisions (default: 10)
        enable_gizmo: Spawn axis indicator during capture (default: True)
        gizmo_size: Size of gizmo arrows in units (default: 80)
        organize_by_type: Create subfolders for different view types (default: True)
        auto_cleanup: Automatically clean up temporary actors after capture (default: True)
        auto_exposure_min: Minimum brightness for auto-exposure (default: 0.3)
        auto_exposure_max: Maximum brightness for auto-exposure (default: 2.0)
        auto_exposure_bias: Exposure compensation in EV stops (default: 0.0)

    Returns:
        dict: Dictionary with view type keys and lists of saved file paths
    """
    if target_location is None:
        target_location = unreal.Vector(0, 0, 0)

    if not loaded_world:
        unreal.log_error("[ERROR] loaded_world is required")
        return {}

    if output_dir is None:
        project_dir = unreal.Paths.project_dir()
        output_dir = os.path.join(project_dir, "Saved", "Screenshots", "Orbital")

    capture_dir = get_next_capture_folder(output_dir, folder_prefix)

    actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
    if not actor_subsystem:
        unreal.log_error("[ERROR] Failed to get EditorActorSubsystem")
        return {}

    total_views = 0
    if enable_perspective_views:
        total_views += len(PERSPECTIVE_VIEWS)
    if enable_orthographic_views:
        total_views += len(ORTHOGRAPHIC_VIEWS)
    if enable_birdseye_views:
        total_views += len(BIRDSEYE_VIEWS)

    unreal.log("=" * 60)
    unreal.log("[INFO] Starting Multi-Angle Screenshot Capture")
    unreal.log(f"  Level: {loaded_world.get_name()}")
    unreal.log(f"  Target: ({target_location.x}, {target_location.y}, {target_location.z})")
    unreal.log(f"  Distance: {distance}")
    unreal.log(f"  Resolution: {resolution_width}x{resolution_height}")
    unreal.log(f"  Views: {total_views} total")
    unreal.log(f"    - Perspective: {'ON' if enable_perspective_views else 'OFF'}")
    unreal.log(f"    - Orthographic: {'ON' if enable_orthographic_views else 'OFF'}")
    unreal.log(f"    - Bird's Eye: {'ON' if enable_birdseye_views else 'OFF'}")
    unreal.log(f"  Helpers: Grid={'ON' if enable_grid else 'OFF'}, Gizmo={'ON' if enable_gizmo else 'OFF'}")
    unreal.log(f"  Auto cleanup: {'ON' if auto_cleanup else 'OFF'}")
    unreal.log(f"  Output: {capture_dir}")
    unreal.log("=" * 60)

    results = {"perspective": [], "orthographic": [], "birdseye": []}

    # Use transaction to enable cleanup via UNDO
    with unreal.ScopedEditorTransaction("Orbital Screenshot Capture"):
        if enable_grid:
            spawn_reference_grid(actor_subsystem, target_location, grid_size, grid_divisions)

        if enable_gizmo:
            spawn_axis_gizmo(actor_subsystem, target_location, gizmo_size)

        # Capture perspective views
        if enable_perspective_views:
            unreal.log("\n--- PERSPECTIVE VIEWS ---")
            if organize_by_type:
                persp_dir = os.path.join(capture_dir, "perspective")
                os.makedirs(persp_dir, exist_ok=True)
            else:
                persp_dir = capture_dir

            for yaw, pitch, view_name, display_name in PERSPECTIVE_VIEWS:
                cam_loc, cam_rot = calculate_camera_transform(target_location, yaw, pitch, distance)
                saved_path = capture_single_view(
                    actor_subsystem, loaded_world,
                    cam_loc, cam_rot,
                    view_name, display_name,
                    persp_dir,
                    resolution_width, resolution_height,
                    is_orthographic=False,
                    auto_exposure_min=auto_exposure_min,
                    auto_exposure_max=auto_exposure_max,
                    auto_exposure_bias=auto_exposure_bias
                )
                if saved_path:
                    results["perspective"].append(saved_path)

        # Capture orthographic views
        if enable_orthographic_views:
            unreal.log("\n--- ORTHOGRAPHIC VIEWS ---")
            if organize_by_type:
                ortho_dir = os.path.join(capture_dir, "orthographic")
                os.makedirs(ortho_dir, exist_ok=True)
            else:
                ortho_dir = capture_dir

            for yaw, pitch, view_name, display_name in ORTHOGRAPHIC_VIEWS:
                cam_loc, cam_rot = calculate_camera_transform(target_location, yaw, pitch, distance)
                saved_path = capture_single_view(
                    actor_subsystem, loaded_world,
                    cam_loc, cam_rot,
                    view_name, display_name,
                    ortho_dir,
                    resolution_width, resolution_height,
                    is_orthographic=True,
                    ortho_width=ortho_width,
                    auto_exposure_min=auto_exposure_min,
                    auto_exposure_max=auto_exposure_max,
                    auto_exposure_bias=auto_exposure_bias
                )
                if saved_path:
                    results["orthographic"].append(saved_path)

        # Capture bird's eye views
        if enable_birdseye_views:
            unreal.log("\n--- BIRD'S EYE VIEWS ---")
            if organize_by_type:
                bird_dir = os.path.join(capture_dir, "birdseye")
                os.makedirs(bird_dir, exist_ok=True)
            else:
                bird_dir = capture_dir

            for yaw, pitch, view_name, display_name in BIRDSEYE_VIEWS:
                cam_loc, cam_rot = calculate_camera_transform(target_location, yaw, pitch, distance)
                saved_path = capture_single_view(
                    actor_subsystem, loaded_world,
                    cam_loc, cam_rot,
                    view_name, display_name,
                    bird_dir,
                    resolution_width, resolution_height,
                    is_orthographic=False,
                    auto_exposure_min=auto_exposure_min,
                    auto_exposure_max=auto_exposure_max,
                    auto_exposure_bias=auto_exposure_bias
                )
                if saved_path:
                    results["birdseye"].append(saved_path)

    # Clean up temporary actors by undoing the transaction
    if auto_cleanup:
        unreal.SystemLibrary.execute_console_command(None, "TRANSACTION UNDO")
        unreal.log("[CLEANUP] Temporary actors removed via transaction undo")

    total_saved = sum(len(v) for v in results.values())
    unreal.log("\n" + "=" * 60)
    unreal.log("[COMPLETE] Multi-Angle Screenshot Capture Finished")
    unreal.log(f"  Total screenshots: {total_saved}/{total_views}")
    unreal.log(f"    - Perspective: {len(results['perspective'])}")
    unreal.log(f"    - Orthographic: {len(results['orthographic'])}")
    unreal.log(f"    - Bird's Eye: {len(results['birdseye'])}")
    unreal.log(f"  Output directory: {capture_dir}")
    unreal.log("=" * 60)

    return results


def take_orbital_screenshots_with_preset(
    loaded_world,
    preset="orthographic",
    target_location=None,
    distance=500.0,
    output_dir=None,
    folder_prefix="capture",
    resolution_width=800,
    resolution_height=600,
    ortho_width=600.0,
    enable_grid=True,
    grid_size=500.0,
    grid_divisions=10,
    enable_gizmo=True,
    gizmo_size=80.0,
    organize_by_type=True,
    auto_cleanup=True,
    auto_exposure_min=0.3,
    auto_exposure_max=2.0,
    auto_exposure_bias=0.0,
):
    """
    Take orbital screenshots using a preset configuration.

    Args:
        preset: One of "all", "perspective", "orthographic", "birdseye", "horizontal", "technical"
        auto_cleanup: Automatically clean up temporary actors after capture (default: True)
        (other args same as take_orbital_screenshots)

    Returns:
        dict: Dictionary with view type keys and lists of saved file paths
    """
    if preset not in VIEW_PRESETS:
        unreal.log_error(f"[ERROR] Unknown preset: {preset}. Available: {list(VIEW_PRESETS.keys())}")
        return {}

    config = VIEW_PRESETS[preset]

    return take_orbital_screenshots(
        loaded_world=loaded_world,
        target_location=target_location,
        distance=distance,
        output_dir=output_dir,
        folder_prefix=folder_prefix,
        resolution_width=resolution_width,
        resolution_height=resolution_height,
        enable_perspective_views=config["perspective"],
        enable_orthographic_views=config["orthographic"],
        enable_birdseye_views=config["birdseye"],
        ortho_width=ortho_width,
        enable_grid=enable_grid,
        grid_size=grid_size,
        grid_divisions=grid_divisions,
        enable_gizmo=enable_gizmo,
        gizmo_size=gizmo_size,
        organize_by_type=organize_by_type,
        auto_cleanup=auto_cleanup,
        auto_exposure_min=auto_exposure_min,
        auto_exposure_max=auto_exposure_max,
        auto_exposure_bias=auto_exposure_bias,
    )
