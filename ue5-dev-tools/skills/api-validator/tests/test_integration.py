
import unittest
import subprocess
import sys
import os
import tempfile

class TestIntegration(unittest.TestCase):
    def setUp(self):
        # Locate validate.py
        self.script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        self.script_path = os.path.join(self.script_dir, "scripts", "validate.py")
        
        # We need to make sure the mock environment is available to the subprocess
        # Since the subprocess is a separate process, our in-memory mocks won't work unless we set up environment
        # environment variables or if usage relies on 'unreal_mock' existing on disk.
        # Assuming unreal_mock.py exists or is auto-generated by validate.py.
        # But auto-generation requires a stub file.
        
        # For integration test, we might struggle if 'unreal_mock' is not actually generated on disk.
        # However, validate.py has logic: if ensure_mock_module() fails, it prints "no mock".
        # We just want to check it runs and parsing works.
        pass

    def run_validator(self, file_path):
        cmd = [sys.executable, self.script_path, file_path]
        return subprocess.run(cmd, capture_output=True, text=True)

    def test_run_help(self):
        cmd = [sys.executable, self.script_path, "--help"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        self.assertEqual(result.returncode, 0)
        self.assertIn("usage:", result.stdout)

    def test_run_on_file(self):
        # Create a temp file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write("import unreal\nobj = unreal.Object()\n")
            temp_path = f.name

        try:
            # Set PYTHONIOENCODING to handle Unicode on Windows
            env = os.environ.copy()
            env['PYTHONIOENCODING'] = 'utf-8'
            cmd = [sys.executable, self.script_path, temp_path]
            result = subprocess.run(cmd, capture_output=True, env=env)

            # Decode output with utf-8, handling errors gracefully
            stdout = result.stdout.decode('utf-8', errors='replace') if result.stdout else ''
            stderr = result.stderr.decode('utf-8', errors='replace') if result.stderr else ''
            combined_output = stdout + stderr

            # It might return 0 even if validation fails (just prints report)
            # We check output for standard report header
            self.assertIn("UE5 Python API Validation Report", combined_output)
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path)

if __name__ == "__main__":
    unittest.main()
