# asset_diagnostic/core.py
# Core functionality for asset type detection and diagnostic results

import unreal
from enum import Enum
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any


class AssetType(Enum):
    """Supported UE5 asset types for diagnostics."""

    LEVEL = "Level"
    BLUEPRINT = "Blueprint"
    MATERIAL = "Material"
    MATERIAL_INSTANCE = "MaterialInstance"
    STATIC_MESH = "StaticMesh"
    SKELETAL_MESH = "SkeletalMesh"
    TEXTURE = "Texture"
    ANIMATION = "Animation"
    SOUND = "Sound"
    PARTICLE_SYSTEM = "ParticleSystem"
    WIDGET_BLUEPRINT = "WidgetBlueprint"
    DATA_ASSET = "DataAsset"
    UNKNOWN = "Unknown"


class IssueSeverity(Enum):
    """Severity levels for diagnostic issues."""

    ERROR = "ERROR"  # Critical issue that will cause problems
    WARNING = "WARNING"  # Potential issue that should be addressed
    INFO = "INFO"  # Informational note
    SUGGESTION = "SUGGESTION"  # Optimization or best practice suggestion


@dataclass
class DiagnosticIssue:
    """Represents a single diagnostic issue found."""

    severity: IssueSeverity
    category: str  # e.g., "Performance", "Reference", "Configuration"
    message: str
    actor: Optional[str] = None  # Actor name/label
    details: Optional[List[str]] = None  # List of details supporting the diagnosis
    suggestion: Optional[str] = None  # How to fix or improve


@dataclass
class DiagnosticResult:
    """Result of running diagnostics on an asset."""

    asset_path: str
    asset_type: AssetType
    asset_name: str
    issues: List[DiagnosticIssue] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    summary: Optional[str] = None

    @property
    def error_count(self) -> int:
        return sum(1 for i in self.issues if i.severity == IssueSeverity.ERROR)

    @property
    def warning_count(self) -> int:
        return sum(1 for i in self.issues if i.severity == IssueSeverity.WARNING)

    @property
    def has_errors(self) -> bool:
        return self.error_count > 0

    @property
    def has_warnings(self) -> bool:
        return self.warning_count > 0

    def add_issue(
        self,
        severity: IssueSeverity,
        category: str,
        message: str,
        actor: Optional[str] = None,
        details: Optional[List[str]] = None,
        suggestion: Optional[str] = None,
    ):
        """Add a diagnostic issue."""
        self.issues.append(
            DiagnosticIssue(
                severity=severity,
                category=category,
                message=message,
                actor=actor,
                details=details,
                suggestion=suggestion,
            )
        )

    def print_report(self, verbose: bool = False):
        """
        Print the diagnostic report to unreal log.

        Args:
            verbose: If True, print metadata section. If False, print only issues.
        """
        # Build report as a list of lines
        lines = []

        lines.append("")
        lines.append("=" * 80)
        lines.append(f"DIAGNOSTIC REPORT: {self.asset_name}")
        lines.append("=" * 80)
        lines.append(f"Asset Path: {self.asset_path}")
        lines.append(f"Asset Type: {self.asset_type.value}")
        lines.append("")

        if self.summary:
            lines.append(f"Summary: {self.summary}")
            lines.append("")

        # Print metadata only in verbose mode
        if verbose and self.metadata:
            lines.append("## ASSET INFO")
            for key, value in self.metadata.items():
                lines.append(f"  {key}: {value}")
            lines.append("")

        # Print issues by severity
        lines.append("## ISSUES FOUND")
        lines.append(
            f"  Errors: {self.error_count}, Warnings: {self.warning_count}, "
            f"Total: {len(self.issues)}"
        )
        lines.append("")

        if not self.issues:
            lines.append("  [OK] No issues found!")
        else:
            # Group issues by severity
            for severity in [
                IssueSeverity.ERROR,
                IssueSeverity.WARNING,
                IssueSeverity.INFO,
                IssueSeverity.SUGGESTION,
            ]:
                severity_issues = [i for i in self.issues if i.severity == severity]
                if severity_issues:
                    lines.append(f"### {severity.value}S ({len(severity_issues)})")
                    for idx, issue in enumerate(severity_issues, 1):
                        # Header line with actor name if available
                        if issue.actor:
                            lines.append(f"  [{idx}] {issue.actor}")
                            lines.append(f"      [{issue.category}] {issue.message}")
                        else:
                            lines.append(f"  [{idx}] [{issue.category}] {issue.message}")
                        # Details lines
                        if issue.details:
                            lines.append(f"      Details:")
                            for ev in issue.details:
                                lines.append(f"        - {ev}")
                        # Suggestion
                        if issue.suggestion:
                            lines.append(f"      Suggestion: {issue.suggestion}")
                    lines.append("")

        lines.append("=" * 80)
        if self.has_errors:
            lines.append("[FAIL] Diagnostic completed with errors")
        elif self.has_warnings:
            lines.append("[WARN] Diagnostic completed with warnings")
        else:
            lines.append("[OK] Diagnostic completed successfully")
        lines.append("=" * 80)

        # Output as a single log message
        unreal.log("\n".join(lines))


# Asset class name to AssetType mapping
_ASSET_CLASS_MAP = {
    # Levels/Maps
    "World": AssetType.LEVEL,
    "Level": AssetType.LEVEL,
    "MapBuildDataRegistry": AssetType.LEVEL,
    # Blueprints
    "Blueprint": AssetType.BLUEPRINT,
    "BlueprintGeneratedClass": AssetType.BLUEPRINT,
    "AnimBlueprint": AssetType.BLUEPRINT,
    "WidgetBlueprint": AssetType.WIDGET_BLUEPRINT,
    # Materials
    "Material": AssetType.MATERIAL,
    "MaterialFunction": AssetType.MATERIAL,
    "MaterialParameterCollection": AssetType.MATERIAL,
    "MaterialInstanceConstant": AssetType.MATERIAL_INSTANCE,
    "MaterialInstanceDynamic": AssetType.MATERIAL_INSTANCE,
    # Meshes
    "StaticMesh": AssetType.STATIC_MESH,
    "SkeletalMesh": AssetType.SKELETAL_MESH,
    "Skeleton": AssetType.SKELETAL_MESH,
    # Textures
    "Texture": AssetType.TEXTURE,
    "Texture2D": AssetType.TEXTURE,
    "TextureCube": AssetType.TEXTURE,
    "TextureRenderTarget2D": AssetType.TEXTURE,
    # Animations
    "AnimSequence": AssetType.ANIMATION,
    "AnimMontage": AssetType.ANIMATION,
    "BlendSpace": AssetType.ANIMATION,
    "BlendSpace1D": AssetType.ANIMATION,
    "AimOffsetBlendSpace": AssetType.ANIMATION,
    # Sound
    "SoundWave": AssetType.SOUND,
    "SoundCue": AssetType.SOUND,
    "SoundClass": AssetType.SOUND,
    "SoundMix": AssetType.SOUND,
    # Particles
    "ParticleSystem": AssetType.PARTICLE_SYSTEM,
    "NiagaraSystem": AssetType.PARTICLE_SYSTEM,
    "NiagaraEmitter": AssetType.PARTICLE_SYSTEM,
    # Data Assets
    "DataAsset": AssetType.DATA_ASSET,
    "DataTable": AssetType.DATA_ASSET,
    "CurveTable": AssetType.DATA_ASSET,
}


def detect_asset_type(asset_path: str) -> AssetType:
    """
    Detect the type of a UE5 asset from its path.

    Args:
        asset_path: The asset path (e.g., "/Game/Maps/TestLevel")

    Returns:
        AssetType enum value
    """
    if not asset_path:
        return AssetType.UNKNOWN

    # Handle .umap extension explicitly
    if asset_path.endswith(".umap"):
        return AssetType.LEVEL

    try:
        # Try to find the asset data
        asset_data = unreal.EditorAssetLibrary.find_asset_data(asset_path)

        if asset_data and asset_data.is_valid():
            # Get the asset class name
            asset_class = str(asset_data.asset_class_path.asset_name)

            # Look up in the mapping
            if asset_class in _ASSET_CLASS_MAP:
                return _ASSET_CLASS_MAP[asset_class]

            # Check for Blueprint suffix patterns
            if "Blueprint" in asset_class:
                if "Widget" in asset_class:
                    return AssetType.WIDGET_BLUEPRINT
                return AssetType.BLUEPRINT

            # Check for Material patterns
            if "Material" in asset_class:
                if "Instance" in asset_class:
                    return AssetType.MATERIAL_INSTANCE
                return AssetType.MATERIAL

            # Check for Texture patterns
            if "Texture" in asset_class:
                return AssetType.TEXTURE

            # Check for Mesh patterns
            if "StaticMesh" in asset_class:
                return AssetType.STATIC_MESH
            if "SkeletalMesh" in asset_class or "Skeleton" in asset_class:
                return AssetType.SKELETAL_MESH

            unreal.log(f"[DEBUG] Unknown asset class: {asset_class}")

    except Exception as e:
        unreal.log(f"[WARNING] Failed to detect asset type: {e}")

    return AssetType.UNKNOWN


def get_current_level_path() -> Optional[str]:
    """
    Get the path of the currently open level.

    Returns:
        Level path or None if no level is open
    """
    try:
        editor_subsystem = unreal.get_editor_subsystem(unreal.UnrealEditorSubsystem)
        world = editor_subsystem.get_editor_world()

        if world:
            # Get the level's package path
            level = world.get_outer()
            if level:
                return level.get_path_name()
    except Exception as e:
        unreal.log(f"[WARNING] Failed to get current level: {e}")

    return None


def get_selected_assets() -> List[str]:
    """
    Get paths of currently selected assets in Content Browser.

    Returns:
        List of asset paths
    """
    try:
        utility = unreal.EditorUtilityLibrary()
        selected = utility.get_selected_asset_data()
        return [str(asset.package_name) for asset in selected if asset.is_valid()]
    except Exception:
        return []


def load_asset(asset_path: str):
    """
    Load an asset by path.

    Args:
        asset_path: The asset path

    Returns:
        The loaded asset object or None
    """
    try:
        return unreal.EditorAssetLibrary.load_asset(asset_path)
    except Exception as e:
        unreal.log(f"[WARNING] Failed to load asset '{asset_path}': {e}")
        return None


def get_asset_references(asset_path: str) -> Dict[str, List[str]]:
    """
    Get references to and from an asset.

    Args:
        asset_path: The asset path

    Returns:
        Dict with 'dependencies' (what this asset uses) and
        'referencers' (what uses this asset)
    """
    result = {"dependencies": [], "referencers": []}

    try:
        # Get dependencies (what this asset references)
        deps = unreal.EditorAssetLibrary.find_package_referencers_for_asset(
            asset_path, load_assets_to_confirm=False
        )
        result["referencers"] = [str(d) for d in deps] if deps else []

        # Note: Getting dependencies requires different approach
        # unreal.AssetRegistry can be used for more detailed queries

    except Exception as e:
        unreal.log(f"[WARNING] Failed to get references: {e}")

    return result
