# asset_diagnostic/diagnostics/level.py
# Level/Map asset diagnostic

import unreal
import math
from typing import List, Dict, Any, Optional

from .base import BaseDiagnostic
from ..core import AssetType, DiagnosticResult, IssueSeverity
from ..utils import (
    get_actor_size,
    get_actor_facing_direction,
    calculate_distance,
    calculate_distance_2d,
    get_direction,
    get_vertical_relation,
    classify_actor_size,
)


# Actor classes that are considered "tangible" (have physical presence)
TANGIBLE_CLASSES = [
    "StaticMeshActor",
    "SkeletalMeshActor",
    "Character",
    "Pawn",
    "PlayerStart",
]

# Non-physical actor classes to skip
NON_PHYSICAL_CLASSES = [
    "DirectionalLight",
    "PointLight",
    "SpotLight",
    "RectLight",
    "SkyLight",
    "SkyAtmosphere",
    "VolumetricCloud",
    "ExponentialHeightFog",
    "AtmosphericFog",
    "Fog",
    "PostProcessVolume",
    "LightmassImportanceVolume",
    "NavMeshBoundsVolume",
    "BlockingVolume",
    "CameraActor",
    "LevelSequenceActor",
    "Note",
    "WorldSettings",
]


class LevelDiagnostic(BaseDiagnostic):
    """
    Diagnostic for UE5 Level/Map assets.

    Checks for:
    - Missing PlayerStart
    - Actor positioning issues
    - Spatial layout analysis
    - Potential collision issues
    """

    @property
    def supported_types(self) -> List[AssetType]:
        return [AssetType.LEVEL]

    def diagnose(self, asset_path: str = None) -> DiagnosticResult:
        """
        Perform level diagnostics.

        Args:
            asset_path: Optional level path. If None, uses current open level.

        Returns:
            DiagnosticResult with issues found
        """
        # Get current level if path not specified
        if asset_path is None:
            asset_path = self._get_current_level_path() or "CurrentLevel"

        result = self._create_result(asset_path, AssetType.LEVEL)

        # Get all actors
        actors = self._get_all_actors()
        if not actors:
            result.add_issue(
                IssueSeverity.WARNING,
                "Level",
                "No actors found in the current level",
            )
            return result

        result.metadata["total_actors"] = len(actors)

        # Get tangible actors for spatial analysis
        tangible_actors = self._get_tangible_actors(actors)
        result.metadata["tangible_actors"] = len(tangible_actors)

        # Run diagnostic checks
        self._check_player_start(actors, result)
        self._check_actor_positions(tangible_actors, result)
        self._check_overlapping_actors(tangible_actors, result)

        # Generate spatial analysis
        spatial_info = self._generate_spatial_analysis(tangible_actors)
        result.metadata.update(spatial_info)

        # Print detailed level info
        self._print_level_analysis(actors, tangible_actors, result)

        return result

    def _get_current_level_path(self) -> Optional[str]:
        """Get the path of the currently open level."""
        try:
            editor_subsystem = unreal.get_editor_subsystem(unreal.UnrealEditorSubsystem)
            world = editor_subsystem.get_editor_world()
            if world:
                level = world.get_outer()
                if level:
                    return level.get_path_name()
        except Exception:
            pass
        return None

    def _get_all_actors(self) -> List[unreal.Actor]:
        """Get all actors in the current level."""
        try:
            actor_subsystem = unreal.get_editor_subsystem(unreal.EditorActorSubsystem)
            return list(actor_subsystem.get_all_level_actors())
        except Exception:
            return []

    def _is_tangible_actor(self, actor) -> bool:
        """Check if an actor has physical presence."""
        class_name = actor.get_class().get_name()

        for skip in NON_PHYSICAL_CLASSES:
            if skip.lower() in class_name.lower():
                return False

        for tangible in TANGIBLE_CLASSES:
            if tangible.lower() in class_name.lower():
                return True

        # Blueprint classes end with _C
        if class_name.endswith("_C"):
            return True

        return False

    def _get_tangible_actors(self, actors: List[unreal.Actor]) -> List[Dict[str, Any]]:
        """Get tangible actors with their position/size data."""
        tangible = []
        for actor in actors:
            if not self._is_tangible_actor(actor):
                continue

            size = get_actor_size(actor)
            if not size:
                continue

            location = actor.get_actor_location()
            tangible.append(
                {
                    "name": actor.get_actor_label(),
                    "class": actor.get_class().get_name(),
                    "x": location.x,
                    "y": location.y,
                    "z": location.z,
                    "x_extent": size[0],
                    "y_extent": size[1],
                    "z_extent": size[2],
                    "actor": actor,
                }
            )
        return tangible

    def _check_player_start(
        self, actors: List[unreal.Actor], result: DiagnosticResult
    ):
        """Check for PlayerStart presence and configuration."""
        player_starts = [a for a in actors if isinstance(a, unreal.PlayerStart)]

        if not player_starts:
            result.add_issue(
                IssueSeverity.WARNING,
                "Gameplay",
                "No PlayerStart found in the level",
                suggestion="Add a PlayerStart actor for player spawn location",
            )
        elif len(player_starts) > 1:
            result.add_issue(
                IssueSeverity.INFO,
                "Gameplay",
                f"Multiple PlayerStart actors found ({len(player_starts)})",
                details="Multiple spawn points may cause unexpected player placement",
            )
        else:
            # Check PlayerStart position
            ps = player_starts[0]
            location = ps.get_actor_location()
            if location.z < -1000:
                result.add_issue(
                    IssueSeverity.WARNING,
                    "Gameplay",
                    "PlayerStart is at very low Z position",
                    location=f"Z={location.z:.0f}",
                    suggestion="Ensure PlayerStart is at a valid spawn height",
                )

        result.metadata["player_start_count"] = len(player_starts)

    def _check_actor_positions(
        self, actors: List[Dict[str, Any]], result: DiagnosticResult
    ):
        """Check for suspicious actor positions."""
        for actor in actors:
            # Check for actors at world origin (might be unintentional)
            if abs(actor["x"]) < 1 and abs(actor["y"]) < 1 and abs(actor["z"]) < 1:
                result.add_issue(
                    IssueSeverity.INFO,
                    "Position",
                    f"Actor at world origin",
                    location=actor["name"],
                    details="This might be intentional or might need repositioning",
                )

            # Check for actors at extreme positions
            if (
                abs(actor["x"]) > 1000000
                or abs(actor["y"]) > 1000000
                or abs(actor["z"]) > 1000000
            ):
                result.add_issue(
                    IssueSeverity.WARNING,
                    "Position",
                    f"Actor at extreme position",
                    location=actor["name"],
                    details=f"Position: ({actor['x']:.0f}, {actor['y']:.0f}, {actor['z']:.0f})",
                )

    def _check_overlapping_actors(
        self, actors: List[Dict[str, Any]], result: DiagnosticResult
    ):
        """Check for potentially overlapping actors."""
        overlap_threshold = 10  # units

        for i, a1 in enumerate(actors):
            for a2 in actors[i + 1 :]:
                dist = calculate_distance(a1, a2)
                min_separation = (
                    max(a1["x_extent"], a1["y_extent"])
                    + max(a2["x_extent"], a2["y_extent"])
                ) / 2

                if dist < overlap_threshold and a1["class"] == a2["class"]:
                    result.add_issue(
                        IssueSeverity.INFO,
                        "Collision",
                        f"Actors potentially overlapping",
                        location=f"{a1['name']} and {a2['name']}",
                        details=f"Distance: {dist:.1f} units",
                    )

    def _generate_spatial_analysis(
        self, actors: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """Generate spatial analysis metadata."""
        if not actors:
            return {}

        min_x = min(a["x"] for a in actors)
        max_x = max(a["x"] for a in actors)
        min_y = min(a["y"] for a in actors)
        max_y = max(a["y"] for a in actors)
        min_z = min(a["z"] for a in actors)
        max_z = max(a["z"] for a in actors)

        return {
            "level_bounds": {
                "min": (min_x, min_y, min_z),
                "max": (max_x, max_y, max_z),
            },
            "level_dimensions": {
                "width": max_x - min_x,
                "length": max_y - min_y,
                "height": max_z - min_z,
            },
            "level_center": (
                (min_x + max_x) / 2,
                (min_y + max_y) / 2,
                (min_z + max_z) / 2,
            ),
        }

    def _print_level_analysis(
        self,
        all_actors: List[unreal.Actor],
        tangible_actors: List[Dict[str, Any]],
        result: DiagnosticResult,
    ):
        """Print detailed level analysis."""
        unreal.log("")
        unreal.log("=" * 80)
        unreal.log("LEVEL ANALYSIS")
        unreal.log("=" * 80)

        # Actor summary
        unreal.log(f"\n## ACTOR SUMMARY")
        unreal.log(f"Total actors: {len(all_actors)}")
        unreal.log(f"Tangible actors: {len(tangible_actors)}")

        # Level dimensions
        if "level_dimensions" in result.metadata:
            dims = result.metadata["level_dimensions"]
            unreal.log(f"\n## LEVEL DIMENSIONS")
            unreal.log(
                f"Size: {dims['width']:.0f} x {dims['length']:.0f} x {dims['height']:.0f} units"
            )

        # Actor registry
        if tangible_actors:
            unreal.log(f"\n## ACTOR REGISTRY ({len(tangible_actors)} tangible)")
            unreal.log("-" * 60)

            sorted_actors = sorted(
                tangible_actors,
                key=lambda a: a["x_extent"] * a["y_extent"] * a["z_extent"],
                reverse=True,
            )

            for i, actor in enumerate(sorted_actors[:20], 1):  # Top 20
                size_cat = classify_actor_size(actor)
                unreal.log(f"[{i}] {actor['name']}")
                unreal.log(f"    Type: {actor['class']}")
                unreal.log(
                    f"    Size: {actor['x_extent']:.0f} x {actor['y_extent']:.0f} x {actor['z_extent']:.0f} ({size_cat})"
                )
                unreal.log(
                    f"    Position: ({actor['x']:.0f}, {actor['y']:.0f}, {actor['z']:.0f})"
                )

                facing = get_actor_facing_direction(actor["actor"])
                if facing:
                    yaw, pitch, roll, direction, forward = facing
                    if abs(yaw) > 0.1 or abs(pitch) > 0.1 or abs(roll) > 0.1:
                        unreal.log(f"    Facing: {direction}")

            if len(tangible_actors) > 20:
                unreal.log(f"\n... and {len(tangible_actors) - 20} more actors")

        # Spatial relationships
        if len(tangible_actors) > 1:
            unreal.log(f"\n## SPATIAL RELATIONSHIPS")
            for actor in tangible_actors[:5]:  # Top 5
                relationships = []
                for other in tangible_actors:
                    if other["name"] == actor["name"]:
                        continue
                    dist = calculate_distance_2d(actor, other)
                    direction = get_direction(actor, other)
                    vertical = get_vertical_relation(actor, other)
                    relationships.append(
                        {
                            "target": other["name"],
                            "direction": direction,
                            "vertical": vertical,
                            "dist": dist,
                        }
                    )

                relationships.sort(key=lambda r: r["dist"])

                unreal.log(f"\nFROM: {actor['name']}")
                for rel in relationships[:3]:
                    unreal.log(
                        f"  -> {rel['target']}: {rel['dist']:.0f}u {rel['direction']}, {rel['vertical']}"
                    )

        unreal.log("\n" + "=" * 80)
