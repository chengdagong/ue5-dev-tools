# asset_diagnostic/diagnostics/base.py
# Base class for asset diagnostics

from abc import ABC, abstractmethod
from typing import List, Set

import unreal

from ..core import AssetType, DiagnosticResult, IssueSeverity


class BaseDiagnostic(ABC):
    """
    Base class for all asset diagnostics.

    Subclasses must implement:
    - supported_types: Property returning list of AssetType this diagnostic handles
    - diagnose(): Method that performs the diagnostic and returns DiagnosticResult
    """

    @property
    @abstractmethod
    def supported_types(self) -> List[AssetType]:
        """
        Return the asset types this diagnostic can handle.

        Returns:
            List of AssetType enum values
        """
        pass

    @property
    def name(self) -> str:
        """
        Return the name of this diagnostic.
        Default implementation uses class name.
        """
        return self.__class__.__name__

    @property
    def description(self) -> str:
        """
        Return a description of what this diagnostic checks.
        Default implementation uses docstring.
        """
        return self.__doc__ or "No description available"

    def can_handle(self, asset_type: AssetType) -> bool:
        """
        Check if this diagnostic can handle the given asset type.

        Args:
            asset_type: The asset type to check

        Returns:
            True if this diagnostic supports the asset type
        """
        return asset_type in self.supported_types

    @abstractmethod
    def diagnose(self, asset_path: str, verbose: bool = False) -> DiagnosticResult:
        """
        Perform diagnostics on the given asset.

        Args:
            asset_path: Path to the asset to diagnose
            verbose: If True, print comprehensive analysis in addition to issues

        Returns:
            DiagnosticResult containing issues found
        """
        pass

    def _create_result(
        self, asset_path: str, asset_type: AssetType, asset_name: str = None
    ) -> DiagnosticResult:
        """
        Helper to create a DiagnosticResult with common fields filled.

        Args:
            asset_path: The asset path
            asset_type: The asset type
            asset_name: Optional asset name (extracted from path if not provided)

        Returns:
            Initialized DiagnosticResult
        """
        if asset_name is None:
            # Extract name from path
            asset_name = asset_path.rsplit("/", 1)[-1] if "/" in asset_path else asset_path

        return DiagnosticResult(
            asset_path=asset_path,
            asset_type=asset_type,
            asset_name=asset_name,
        )

    def _log_progress(self, message: str):
        """Log a progress message during diagnostic."""
        unreal.log(f"[{self.name}] {message}")


class CompositeDiagnostic(BaseDiagnostic):
    """
    A diagnostic that combines multiple diagnostics.
    Useful for running all applicable diagnostics on an asset.
    """

    def __init__(self, diagnostics: List[BaseDiagnostic] = None):
        self._diagnostics = diagnostics or []

    @property
    def supported_types(self) -> List[AssetType]:
        """Return all types supported by any child diagnostic."""
        types: Set[AssetType] = set()
        for diag in self._diagnostics:
            types.update(diag.supported_types)
        return list(types)

    def add_diagnostic(self, diagnostic: BaseDiagnostic):
        """Add a diagnostic to the composite."""
        self._diagnostics.append(diagnostic)

    def diagnose(self, asset_path: str, verbose: bool = False) -> DiagnosticResult:
        """
        Run all applicable diagnostics and combine results.
        """
        from ..core import detect_asset_type

        asset_type = detect_asset_type(asset_path)
        result = self._create_result(asset_path, asset_type)

        for diag in self._diagnostics:
            if diag.can_handle(asset_type):
                sub_result = diag.diagnose(asset_path, verbose=verbose)
                # Merge issues
                result.issues.extend(sub_result.issues)
                # Merge metadata
                result.metadata.update(sub_result.metadata)

        return result
